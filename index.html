<!DOCTYPE html>
<html lang="fr">
<head>
  <!-- Méta en premier -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>War-ixel</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#1e3a8a">
  <meta name="color-scheme" content="light dark">
  <meta name="apple-mobile-web-app-title" content="War-ixel">
  <!-- iOS -->
  <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-180.png">
  <!-- Si tu n'as pas icon-180.png, garde la ligne suivante à la place :
  <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-192.png">
  -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Service Worker -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('service-worker.js').catch(console.error);
      });
    }
  </script>

<style>
  :root{
    --deep:#255c9e;
    --shallow:#8fd0ff;
    --ai:#b71c1c;
    --select:#ffcc00;
    --my:#1e3a8a;
    --reach-fill:rgba(60,170,120,.32);
    --theo-fill:rgba(100,140,220,.20);
    --bg:#eae4d6;
    --ink:#171717;
    --paper1:#f4e2b8;
    --paper2:#f0d59a;
    --paper3:#e8c77a;
    --paper-ink:#473924;
    --headH:72px; /* hauteur header par défaut */
  }

  .pos { color:#1b8f2f; font-weight:700; }   /* valeurs positives (impôts) */
  .neg { color:#b71c1c; font-weight:700; }   /* valeurs négatives (entretien) */
  .meta-mini { font-size:12px; opacity:.8; margin-top:6px; }

  html, body {
    overscroll-behavior: none;  /* bloque le “rebond”, le scroll chaining et le pull-to-refresh (Chrome/Android) */
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}

  header{
    position:sticky; top:0; z-index:20;
    padding:10px 14px;
    display:flex;flex-wrap:wrap;gap:8px;align-items:center;justify-content:flex-start;
    color:var(--paper-ink);
    border-bottom:1px solid #c8b99c;
    background:linear-gradient(180deg,#fff7 0 10%, #0000 25% 75%, #fff6 90% 100%),
      radial-gradient(55% 120% at -5% -40%, #0002 0 40%, #0000 60%),
      radial-gradient(45% 110% at 110% -40%, #0002 0 40%, #0000 60%),
      linear-gradient(180deg,var(--paper1),var(--paper2) 55%,var(--paper3));
    box-shadow:inset 0 1px 0 #fff7,inset 0 -1px 0 #0001,0 4px 16px rgba(0,0,0,.12);
  }
  @media (display-mode: standalone) {
    @supports (padding: max(0px)) {
      header { padding-top: max(10px, env(safe-area-inset-top)); }
  }
  }

  .paper-chip{padding:6px 10px;border-radius:9px;border:1px solid #d7c7ad;background:#fff9;backdrop-filter:blur(2px)}
  #viewControls{
    position: absolute;
    left: 12px;
    top: 12px;
    z-index: 5;
    display: flex;
    gap: 8px;
    align-items: center;
  }
  .controls{display:flex;gap:8px;align-items:center}
  .controls button{padding:8px 12px;border:1px solid #cdbb98;border-radius:9px;background:#fff9;cursor:pointer;box-shadow:inset 0 1px 0 #fff7}

  .layout{
    display:grid;
    grid-template-columns:320px 1fr;
    grid-template-rows: 1fr;            /* NEW: la seule rangée remplit la hauteur */
    gap:12px;
    padding:12px;
    height: calc(100dvh - var(--headH, 72px));
    min-height: 0;                      /* sécurité */
  }


 /* Mode compact: paysage petit écran */
  @media (max-width: 920px) and (orientation: landscape) {
    .layout {
      grid-template-columns: 1fr;
      grid-template-rows: 1fr;          /* NEW: idem en paysage */
      padding: 0;
      height: calc(100dvh - var(--headH, 72px));
    }

    #board {
      padding: 0;
      border: 0;
      border-radius: 0;
      height: 100%;
    }

    /* Sidebar en tiroir à droite */
    #sidebar {
      position: fixed; top: 0; right: 0; height: 100vh; width: 320px;
      transform: translateX(100%); transition: transform .25s ease;
      z-index: 55; background: linear-gradient(180deg,#fff9 0 10%, #0000 30% 70%, #fff6 90% 100%),
        repeating-linear-gradient(6deg,#0000 0 12px,#0001 12px 13px),
        linear-gradient(180deg, var(--paper1), var(--paper2) 55%, var(--paper3));
      border-left: 1px solid #d7c7ad; padding: 10px; overflow: auto;
    }
    body.show-sidebar #sidebar { transform: translateX(0); }

    /* Contrôles de zoom */
    #viewControls { left: 8px; top: 8px; }
  }

  #sidebar, #board{min-height:0;}
  #board{height:100%;}                   /* NEW: occupe 100% de la rangée */
  #sidebar{display:flex;flex-direction:column;gap:12px;overflow:auto}

  .paper{
    border-radius:14px;border:1px solid #d7c7ad;color:var(--paper-ink);padding:12px 14px;
    background:linear-gradient(180deg,#fff9 0 10%, #0000 30% 70%, #fff6 90% 100%),
      repeating-linear-gradient( 6deg, #0000 0 12px, #0001 12px 13px),
      linear-gradient(180deg, var(--paper1), var(--paper2) 55%, var(--paper3));
    box-shadow:inset 0 1px 0 #fff7,inset 0 -1px 0 #0001,0 10px 24px rgba(0,0,0,.18);
  }
  .paper h3{margin:0 0 8px 0;color:#3b2f20}

  #actions{display:grid;gap:6px}
  #actions button{
    padding:10px 12px;border-radius:10px;border:1px solid #cdbb98;cursor:pointer;
    text-align:left;display:flex;flex-direction:column;align-items:flex-start;gap:2px;
    background:linear-gradient(180deg,#fff9 0 30%, #0000 60%),
      repeating-linear-gradient(6deg,#0000 0 12px,#0001 12px 13px),
      linear-gradient(180deg,#f7e8bf,#f2d793 55%,#e6c377);
    box-shadow:inset 0 1px 0 #fff7, 0 2px 8px rgba(0,0,0,.08);
  }
  #actions button .title{font-weight:700;color:#3b2f20}
  #actions button .meta{font-size:12px;opacity:.8;color:#473924}
  #actions button[disabled]{display:none;}
  #actions .hint-msg{
    padding:10px 12px;border-radius:10px;border:1px dashed #cdbb98;
    background:#fff7;color:#473924;
  }

  #log{max-height:240px;overflow:auto}
  .entry{border-bottom:1px dashed #d7c7ad;padding:6px 0}
  .entry:last-child{border-bottom:0}
  .summary{cursor:pointer;font-weight:700}
  .detail{max-height:0;overflow:hidden;transition:max-height .25s ease;font-size:12px;color:#3f3527}
  .entry.open .detail{max-height:260px}
  .entry[data-owner="1"] .summary{color:var(--my)}
  .entry[data-owner="2"] .summary{color:var(--ai)}

  #board{
    position:relative;border:1px solid #c8bfae;border-radius:12px;padding:18px;
    display:flex;align-items:center;justify-content:center;
    background:repeating-linear-gradient(45deg, #cfe7ff 0 18px, #d8edff 18px 36px),
      radial-gradient(80% 60% at 0% 10%, #0000000b 0 50%, #0000 70%),
      radial-gradient(70% 70% at 100% 90%, #0000000d 0 50%, #0000 75%),
      linear-gradient(180deg, #fff, #fdfbf7 55%, #faf6ef);
    overflow:hidden; cursor:grab;
      touch-action: none;             /* empêche le scroll natif, on gère le drag nous-mêmes */
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
  }
  #board.dragging{cursor:grabbing}

  #stage{position:relative;margin:auto}
  #terrain, #overlay, #grid{position:absolute;left:0;top:0}
  #overlay{pointer-events:none;z-index:2}
  #grid{z-index:3}
  #world{position:absolute;left:0;top:0;will-change:transform}

  .hex{position:absolute;left:0;top:0;transform:translate(-50%,-50%);cursor:pointer}
  .hex.selected{
    outline:3px solid var(--select);outline-offset:-2px;
    box-shadow:0 0 0 3px rgba(255,204,0,.45), 0 0 26px rgba(255,204,0,.55) inset;
  }
  @keyframes selping{
    0%{transform:translate(-50%,-50%) scale(.7); opacity:.9;}
    70%{transform:translate(-50%,-50%) scale(1.25); opacity:0;}
    100%{opacity:0;}
  }
  .hex.selected::after{
    content:"";position:absolute; left:50%; top:50%;
    width:56px; height:56px; transform:translate(-50%,-50%);
    border-radius:50%; border:2px solid var(--select);
    opacity:.85; animation:selping 1.1s ease-out infinite;
  }

  .city, .tower{z-index: 1;}
  .badge{z-index: 2;}

  .badge{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    width:34px;height:34px;border-radius:50%;
    display:flex;align-items:center;justify-content:center;
    border:2px solid rgba(255,255,255,.85);box-shadow:0 1px 1px rgba(0,0,0,.08)
  }
  .badge .icon{width:18px;height:18px;display:block}
  .badge::after{content:none !important}
  .camo{opacity:.82}
  .camo::before{content:"";position:absolute;inset:-2px;background:repeating-linear-gradient(135deg,transparent 0 6px,rgba(0,0,0,.06) 6px 12px);mix-blend-mode:multiply;border-radius:8px}

  .tower,.city{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:32px;height:28px;border-radius:6px;border:2px solid rgba(0,0,0,.15)}
  .city{background:#c68c53;display:grid;place-items:center}
  .tower{background:#e0e0e0;display:grid;place-items:center}
  .tower svg{width:22px;height:22px}
  .castle{width:22px;height:16px}
  .ship{
    width:42px;height:26px;border-radius:6px;color:#fff;border:2px solid rgba(255,255,255,.85);
    display:flex;align-items:center;justify-content:center;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    box-shadow:0 1px 1px rgba(0,0,0,.08)
  }
  .hint{position:absolute;right:3px;top:2px;font-size:11px;background:rgba(0,0,0,.7);color:#fff;padding:1px 5px;border-radius:999px;z-index:4}

  #summary{display:grid;gap:8px}
  .sum-title{font-weight:700;margin-bottom:4px}
  .sum-list{margin:0;padding-left:0;list-style:none;display:grid;gap:3px}
  .sum-item{display:flex;align-items:center;justify-content:space-between;gap:6px;font-variant-numeric:tabular-nums;width:100%}
  .sum-ico{width:16px;height:16px;display:inline-block;vertical-align:middle}

  #overlay polygon{stroke-linejoin:round; vector-effect:non-scaling-stroke; shape-rendering:geometricPrecision;}

  .modal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:1000}
  .modal.show{display:flex}
  .card{background:#fff;border-radius:12px;border:1px solid #ddd;padding:16px;max-width:620px;width:92%;box-shadow:0 12px 30px rgba(0,0,0,.25)}
  .sizes{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:8px}
  .swatches{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  .swatch{width:28px;height:28px;border-radius:6px;border:2px solid #ddd;cursor:pointer;box-shadow:inset 0 0 0 2px rgba(255,255,255,.35)}
  .swatch[data-sel="1"]{outline:3px solid #0003}

  .hex.frontier{ box-shadow: inset 0 0 0 2px rgba(0,0,0,.12); }
  .hex.frontier.owned1{ box-shadow: inset 0 0 0 2px rgba(30,58,138,.35); }
  .hex.frontier.owned2{ box-shadow: inset 0 0 0 2px rgba(183,28,28,.35); }
  /* Bouton flottant pour ouvrir/fermer le tiroir */
  .fab {
    position: fixed; bottom: 12px; right: 12px; z-index: 60;
    width: 48px; height: 48px; border-radius: 9999px;
    display: flex; align-items: center; justify-content: center;
    background: #fff; border: 1px solid #cdbb98;
    box-shadow: 0 6px 18px rgba(0,0,0,.22); cursor: pointer;
  }
 

  /* Ajuste les safe areas quand l’app est installée (standalone) */
  @media (display-mode: standalone) {
    .fab {
      bottom: calc(12px + env(safe-area-inset-bottom));
      right:  calc(12px + env(safe-area-inset-right));
    }
  }
    /* ── Barre de vie au-dessus des unités ─────────────────────────── */
.hpbar {
  position: absolute; left: 50%; top: -10px; transform: translateX(-50%);
  width: 30px; height: 6px; border-radius: 4px; background: rgba(0,0,0,.25);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.35); border: 1px solid rgba(255,255,255,.7);
  z-index: 4;
}
.hpbar .hpfill { height: 100%; border-radius: 3px; background: linear-gradient(90deg,#9be15d,#00e3ae); width: 100%; }

  /* Focus visible au clavier sur les cases hex */
  .hex:focus { outline: 3px solid var(--select); outline-offset: -2px; }


</style>
</head>
<body>
<header>
  <div class="paper-chip">Tour: <b id="turnLabel">Joueur</b></div>
  <div class="paper-chip">Année: <b id="yearLabel">1</b></div>
  <div class="paper-chip">Build: <b id="buildLabel"></b></div>
  <div class="controls">
    <button type="button" id="endTurn">Finir le tour</button>
    <button type="button" id="restart">Recommencer</button>
    <button type="button" id="menu">Menu</button>
  </div>
</header>

<div class="layout">
  <!-- ───────── Sidebar ───────── -->
  <div id="sidebar">
    <div class="paper">
      <h3>Actions</h3>
      <div id="actions">
        <button type="button" id="buildCity" disabled>Construire Ville</button>
        <button type="button" id="buildTower" disabled>Bâtir Tour (3 or)</button>
        <button type="button" id="recFarmer"  disabled>Recruter Fermier</button>
        <button type="button" id="recMilitia" disabled>Recruter Milicien</button>
        <button type="button" id="recSoldier" disabled>Recruter Soldat</button>
        <button type="button" id="upFarmMil"  disabled>Améliorer Fermier → Milice</button>
        <button type="button" id="upMilSold"  disabled>Améliorer Milice → Soldat</button>
        <button type="button" id="makeSloop"   disabled>Sloop 1 mât (5 or)</button>
        <button type="button" id="makeBrig"    disabled>Brigantin 2 mâts (10 or)</button>
        <button type="button" id="makeGalleon" disabled>Galion 3 mâts (20 or)</button>
        <button type="button" id="loadShip"    disabled>Embarquer</button>
        <button type="button" id="disembark"   disabled>Débarquer</button>
      </div>
    </div>

    <div class="paper">
      <h3>Gestion</h3>
      <div id="summary" style="font-size:13px;line-height:1.2"></div>
    </div>

    <div class="paper">
      <h3>Journal</h3>
      <div id="log" aria-live="polite"></div>
      <div class="meta-mini">
      </div>
    </div>
  </div><!-- /#sidebar -->

  <!-- ───────── Plateau ───────── -->
  <div id="board">
    <div id="viewControls" class="paper-chip">
      <button type="button" id="zoomOut" aria-label="Zoom out">−</button>
      <span id="zoomLabel">100%</span>
      <button type="button" id="zoomIn"  aria-label="Zoom in">+</button>
    </div>

    <div id="world">
      <div id="stage">
        <svg id="terrain"></svg>
        <svg id="overlay"></svg>
        <div id="grid"></div>
      </div>
    </div>
  </div><!-- /#board -->
</div><!-- /.layout -->

  <!-- MODAL DE DÉMARRAGE -->
  <div id="start" class="modal" role="dialog" aria-modal="true" aria-labelledby="start-title">
    <div class="card">
      <h2 id="start-title">War-ixel — Nouvelle partie</h2>
      <p>Choisis <b>ta couleur</b>, la <b>taille</b>, le <b>nombre d'IA</b>, leurs <b>alliances</b> et la <b>difficulté</b> (1 novice → 4 chef de guerre), puis (optionnel) une <b>seed</b> :</p>
      <div class="swatches" id="swatches"></div>
      <div style="margin-top:10px; display:grid; gap:8px; grid-template-columns:repeat(2,1fr);">
        <label>IA (0–4)<br><input id="aiCount" type="number" min="0" max="4" value="1" style="width:100%"></label>
        <label>IA alliées entre elles ?<br><select id="aiAllied" style="width:100%"><option value="1" selected>Oui</option><option value="0">Non</option></select></label>
        <label>Difficulté<br>
          <select id="difficulty" style="width:100%">
            <option value="1">1 — Novice</option>
            <option value="2" selected>2 — Normal</option>
            <option value="3">3 — Stratège</option>
            <option value="4">4 — Chef de guerre</option>
          </select>
        </label>
        <div></div>
      </div>
      <div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
        <label style="min-width:42px;">Seed</label>
        <input id="seedInput" type="text" placeholder="aléatoire" style="flex:1; padding:6px 8px; border:1px solid #ccc; border-radius:8px;">
        <button type="button" id="diceSeed" title="Seed aléatoire">🎲</button>
        <button type="button" id="copySeed" title="Copier la seed">📋</button>
        <span id="seedLabel" style="font-size:12px; opacity:.8; margin-left:8px;"></span>
      </div>

      <div class="sizes" style="margin-top:8px">
        <button type="button" data-size="small">Petit</button>
        <button type="button" data-size="medium">Moyen</button>
        <button type="button" data-size="large">Grand</button>
        <button type="button" data-size="huge">Immense</button>
      </div>
    </div>
</div>

<button type="button" id="toggleSidebar" class="fab" aria-label="Ouvrir le menu" aria-pressed="false">☰</button>

<script>
(function(){

const R = 34, HEX_W = 2*R, HEX_H = Math.sqrt(3)*R, STEP_X = 1.5*R, STEP_Y = HEX_H;
function hexCenter(x,y){ return { cx: x*STEP_X+R, cy: y*STEP_Y + ((x&1)?HEX_H/2:0) + HEX_H/2 }; }
function svgHexPoints(cx,cy,shrink=1){ const r=R*shrink, h=Math.sqrt(3)*r;
  const pts=[[cx-r/2,cy-h/2],[cx+r/2,cy-h/2],[cx+r,cy],[cx+r/2,cy+h/2],[cx-r/2,cy+h/2],[cx-r,cy]];
  return pts.map(p=>p.join(',')).join(' ');
}

const UNITS={1:{key:1,name:'Fermier',cost:1,upkeep:0.5,move:3},2:{key:2,name:'Milicien',cost:2,upkeep:1,move:2},3:{key:3,name:'Soldat',cost:3,upkeep:1.5,move:1}};
const SHIPS={sloop:{key:'sloop',name:'Sloop',cost:5,upkeep:2.5,move:3,water:'shallow',cap:1,hp:2,atk:1,masts:1},
             brig:{key:'brig',name:'Brigantin',cost:10,upkeep:5,move:2,water:'both',cap:2,hp:3,atk:1.5,masts:2},
             galleon:{key:'galleon',name:'Galion',cost:20,upkeep:10,move:1,water:'both',cap:3,hp:4,atk:2,masts:3}};


// ── HP par type ──────────────────────────────────────────────────
function baseHP(type){ return type===1 ? 50 : (type===2 ? 100 : 150); }

// Normalise un objet unité pour lui ajouter hp/hpMax si absent
function ensureHP(u){
  const lvl = u.level || 1;
  const max = baseHP(u.type) * lvl;
  u.hpMax = (typeof u.hpMax === 'number') ? u.hpMax : max;
  u.hp    = (typeof u.hp    === 'number') ? u.hp    : max;
  if (u.hpMax !== max){ u.hp = Math.round(u.hp * (max / u.hpMax)); u.hpMax = max; }
  if (u.hp > u.hpMax) u.hp = u.hpMax;
  return u;
}

// Dommages subis par l'attaquant en cas de victoire.
function victoryDamage(attType, defType){
  if (attType === defType) return { type: 'setToHalf' };
  if (attType === 2 && defType === 1) return { type: 'flat', dmg: 10 }; // Milice > Fermier
  if (attType === 3 && defType === 2) return { type: 'flat', dmg: 20 }; // Soldat > Milice
  if (attType === 3 && defType === 1) return { type: 'flat', dmg: 10 }; // Soldat > Fermier
  return { type: 'flat', dmg: 0 };
}

// Applique le malus de victoire à l'attaquant (toujours gagnant)
function applyVictoryDamageToUnit(u, attType, defType){
  ensureHP(u);
  const rule = victoryDamage(attType, defType);
  if (rule.type === 'setToHalf'){
    u.hp = Math.max(1, Math.ceil(u.hpMax * 0.5));
  } else {
    u.hp = Math.max(1, u.hp - rule.dmg);
  }
}

// Adjacent à une ville/tour alliée ?
function isAdjacentToOwnStronghold(x,y,owner){
  return neighbors(x,y).some(([nx,ny])=>{
    const t = cell(nx,ny);
    return t && (t.structure === 'city' || t.structure === 'tower') && t.owner === owner;
  });
}

// Régénération : +20% PV max si adjacente à ville/tour alliée
function healUnits(owner){
  for (const c of S){
    if (c.unit && c.unit.owner === owner){
      if (isAdjacentToOwnStronghold(c.x, c.y, owner)){
        ensureHP(c.unit);
        const gain = Math.round(c.unit.hpMax * 0.2);
        c.unit.hp = Math.min(c.unit.hpMax, c.unit.hp + gain);
      }
    }
  }
}

const DEF_BONUS_CITY = 0.5;         // bonus défense si l'unité défend dans SA ville
const GARRISON_UPKEEP_MULT = 0.5;   // entretien x0.5 pour une unité posée sur SA ville

const SUPPLY_PER_CITY = 3;          // capacité gratuite par ville
const SUPPLY_PER_LAND = 0.12;       // +cap par tuile terrestre possédée
const SHIP_SUPPLY = { sloop:1, brig:2, galleon:3 }; // poids supply des navires
const SUPPLY_OVER_COST = 1.0;       // coût d'entretien par point au-dessus du cap

const CAMO_RANGE = 5;
const CITY_BASE_COST=10, CITY_SCALE=3;
const SIZE_PRESETS={small:{W:13,H:11},medium:{W:19,H:15},large:{W:25,H:19},huge:{W:33,H:25}};

let W=13,H=11,S=[],selected=null,reach=[],reachTheo=[],turn=1,TOTAL_PLAYERS=2,AI_ALLIED=true,DIFFICULTY=2;
let YEAR=1;
let uiLocked=false, turnCount=1;
const gold={};
const PLAYER_COLORS=[{n:"Émeraude",v:"#1f7a3e"},{n:"Bleu roi",v:"#1e3a8a"},{n:"Violet",v:"#6a1b9a"},{n:"Ambre",v:"#e39a1d"},{n:"Carmin",v:"#c62828"},{n:"Teal",v:"#00897b"}];
let playerColor=PLAYER_COLORS[1].v;
const AI_PALETTE=["#b71c1c","#6a1b9a","#e39a1d","#00897b"];
function ownerColor(o){ if(o===1) return playerColor; return AI_PALETTE[(o-2)%AI_PALETTE.length]; }

let zoom=1, panX=0, panY=0;
const MIN_ZOOM=0.6, MAX_ZOOM=2.0, ZOOM_STEP=0.1;
let isDragging=false, dragStartX=0, dragStartY=0, panStartX=0, panStartY=0, justPanned=false;
let WpxCached=0, HpxCached=0;

const boardEl=document.getElementById('board'), stageEl=document.getElementById('stage'),
      worldEl=document.getElementById('world'), terrain=document.getElementById('terrain'),
      overlay=document.getElementById('overlay'), gridEl=document.getElementById('grid'), 
      logEl=document.getElementById('log'), endBtn=document.getElementById('endTurn');

let CURRENT_SIZE='small', CURRENT_SEED=0;
function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296;};}
let rand=Math.random;
function hashStringToInt(s){ if(s==null) return 0; if(/^0x/i.test(s)) return parseInt(s,16)>>>0; if(/^\d+$/.test(s)) return (parseInt(s,10)>>>0);
  return Array.from(String(s)).reduce((h,ch)=>(Math.imul(31,h)+ch.charCodeAt(0))>>>0,0);}
function setSeed(s){ const n=(typeof s==='string')?hashStringToInt(s):(s>>>0); CURRENT_SEED=(n||1)>>>0; rand=mulberry32(CURRENT_SEED); const sl = document.getElementById('seedLabel');
if (sl) sl.textContent = CURRENT_SEED; }
function hexToRgb(h){h=h.replace('#','');if(h.length===3)h=[...h].map(x=>x+x).join('');const num=parseInt(h,16);return{r:(num>>16)&255,g:(num>>8)&255,b:num&255};}
function rgbToHex(r,g,b){const t=n=>n.toString(16).padStart(2,'0');return '#'+t(r)+t(g)+t(b);}
function mix(c1,c2,p){const a=hexToRgb(c1),b=hexToRgb(c2);return rgbToHex(Math.round(a.r+(b.r-a.r)*p),Math.round(a.g+(b.g-a.g)*p),Math.round(a.b+(b.b-a.b)*p));}
function regionColor(owner){ if(owner===0) return '#dbdbdb'; const base=ownerColor(owner); return mix(base,'#ffffff',0.60); }

function hash(i,j){const s=Math.sin(i*127.1+j*311.7+(CURRENT_SEED||0))*43758.5453;return s-Math.floor(s);}
function lerp(a,b,t){return a+(b-a)*t;} function fade(t){return t*t*(3-2*t);}
function noise2(x,y){const i=Math.floor(x),j=Math.floor(y);const u=fade(x-i),v=fade(y-j);const a=hash(i,j),b=hash(i+1,j),c=hash(i,j+1),d=hash(i+1,j+1);return lerp(lerp(a,b,u),lerp(c,d,u),v);}
function fbm(x,y,oct=4){let v=0,amp=0.5,freq=1;for(let o=0;o<oct;o++){v+=noise2(x*freq,y*freq)*amp;freq*=2;amp*=0.5;}return v;}

function inb(x,y){return x>=0&&y>=0&&x<W&&y<H;}
function idx(x,y){return y*W+x;}
function cell(x,y){ if(!inb(x,y)) return undefined; return S[idx(x,y)]; }
function neighbors(x,y){
  const out=[]; const odd=x&1;
  const E=[[-1,0],[+1,0],[0,-1],[0,+1],[-1,-1],[-1,+1]];
  const O=[[-1,0],[+1,0],[0,-1],[0,+1],[+1,-1],[+1,+1]];
  const dirs=odd?O:E;
  for(const[dx,dy] of dirs){ const nx=x+dx, ny=y+dy; if(inb(nx,ny)) out.push([nx,ny]); }
  return out;
}
function toCube(q,r){const x=q;const z=r-((q&1)?(q+1)/2:q/2);const y=-x-z;return{x,y,z};}
function hexDist(a,b){const ac=toCube(a.x,a.y),bc=toCube(b.x,b.y);return Math.max(Math.abs(ac.x-bc.x),Math.abs(ac.y-bc.y),Math.abs(ac.z-bc.z));}

function genMap(sizeKey, aiCount=1, allied=true, difficulty=2){
  AI_ALLIED=!!+allied; DIFFICULTY=+difficulty||2; TOTAL_PLAYERS=1+(+aiCount||0);
  const p=SIZE_PRESETS[sizeKey]||SIZE_PRESETS.small; W=p.W; H=p.H; S.length=0;
  for(let y=0;y<H;y++)for(let x=0;x<W;x++)S.push({x,y,terrain:'land',owner:0,structure:'none',unit:null,ship:null,e:0,shore:false});

  for(const c of S){
    const sx=c.x/W*6, sy=c.y/H*6; const elev=fbm(sx,sy,5), humid=fbm(sx+20,sy-13,4); c.e=elev;
    const edge=Math.min(c.x,W-1-c.x,c.y,H-1-c.y)/Math.min(W,H);
    const coastBias=(edge<0.08)?-0.2:0; const seaLevel=0.50+coastBias;
    if(elev<seaLevel-0.12) c.terrain='deep';
    else if(elev<seaLevel) c.terrain='shallow';
    else c.terrain=(humid>0.53?'forest':'land');
  }
  for(const c of S) if(c.terrain==='deep'&&neighbors(c.x,c.y).some(([nx,ny])=>['land','forest'].includes(cell(nx,ny)?.terrain))) c.terrain='shallow';
  for(const c of S) c.shore=((c.terrain==='land'||c.terrain==='forest') && neighbors(c.x,c.y).some(([nx,ny])=> ['shallow','deep'].includes(cell(nx,ny)?.terrain)));

  const starts=[]; starts.push(findNearestLandOnly(1,1));
  for(let k=0;k<aiCount;k++){const p2=randomFarLandOnly(starts,Math.floor(Math.min(W,H)/2.2))||randomFarLandOnly(starts,6)||findNearestLandOnly(W-2,H-2); starts.push(p2);}

  for(let i=0;i<starts.length;i++){
    const o=i+1, p3=starts[i];
    const city = cell(p3.x,p3.y);
    city.structure='city'; city.owner=o;

    const cand = neighbors(p3.x,p3.y).find(([nx,ny])=>{
      const t=cell(nx,ny);
      if(!t) return false;
      if(t.structure!=='none'||t.unit||t.ship) return false;
      if(!(t.terrain==='land'||t.terrain==='forest')) return false;
      if(!passableForUnit(city,t,o,1)) return false;
      return (t.owner===o) || (t.owner===0 && canAnnex(o,nx,ny));
    });
    if (cand){
      const [ux,uy]=cand; const t=cell(ux,uy);
      t.unit = ensureHP({ owner:o, type:1, level:1, moved:true });
      t.owner=o;
    }
    gold[o]=2;
  }
  turn=1; turnCount=1; recalcMoved(false); YEAR=1;
}

function findNearestLandOnly(sx,sy){let best={x:sx,y:sy},bestD=1e9;for(const c of S){if(c.terrain==='land'){const d=Math.abs(c.x-sx)+Math.abs(c.y-sy);if(d<bestD){bestD=d;best={x:c.x,y:c.y};}}}return best;}
function randomFarLandOnly(points,minD){const candidates=S.filter(c=>(c.terrain==='land')&&c.structure==='none');for(let t=0;t<800;t++){const c=candidates[Math.floor(rand()*candidates.length)];if(!c)break;if(points.every(p=>hexDist(c,p)>=minD))return{x:c.x,y:c.y};}return null;}
function recalcMoved(flag){for(const c of S){if(c.unit)c.unit.moved=flag;if(c.ship)c.ship.moved=flag;}}

function income(o){let inc=0;for(const c of S){if(c.owner===o&&(c.terrain==='land'||c.terrain==='forest'))inc++; if(c.owner===o&&c.structure==='city')inc+=2;} return inc;}
// --- NEW: décomposition exacte de l'entretien pour l'UI ---
function upkeepBreakdown(owner){
  const byUnit = {1:0, 2:0, 3:0};
  const byShip = {sloop:0, brig:0, galleon:0};
  let landOwned = 0, cities = 0, supplyUsed = 0;

  for (const c of S){
    if (c.owner === owner && (c.terrain==='land' || c.terrain==='forest')) landOwned++;
    if (c.owner === owner && c.structure === 'city') cities++;

    if (c.unit && c.unit.owner === owner){
      const lvl = (c.unit.level || 1);
      let uCost = UNITS[c.unit.type].upkeep * lvl;
      if (c.structure === 'city' && c.owner === owner) uCost *= GARRISON_UPKEEP_MULT; // -50% en garnison
      byUnit[c.unit.type] += uCost;
      supplyUsed += lvl;
    }

    if (c.ship && c.ship.owner === owner){
      byShip[c.ship.kind] += SHIPS[c.ship.kind].upkeep;
      supplyUsed += (SHIP_SUPPLY[c.ship.kind] || 1);
    }
  }

  const cap = Math.floor(cities * SUPPLY_PER_CITY + landOwned * SUPPLY_PER_LAND);
  const over = Math.max(0, supplyUsed - cap);
  const overCost = over * SUPPLY_OVER_COST;

  const total = +(byUnit[1] + byUnit[2] + byUnit[3] + byShip.sloop + byShip.brig + byShip.galleon + overCost).toFixed(1);
  return { byUnit, byShip, cap, supplyUsed, over, overCost, total };
}

// Garde cette signature pour le reste du code (IA, etc.)
function upkeep(o){ return upkeepBreakdown(o).total; }

function cityCost(o){const owned=S.filter(c=>c.structure==='city'&&c.owner===o).length-1;return CITY_BASE_COST + CITY_SCALE*Math.max(0,owned);}
function countSummary(o){const units={1:0,2:0,3:0}, ships={sloop:0,brig:0,galleon:0}; for(const c of S){if(c.unit&&c.unit.owner===o)units[c.unit.type]+=(c.unit.level||1); if(c.ship&&c.ship.owner===o)ships[c.ship.kind]++;} return{units,ships};}

function renderSummary(){
  const box = document.getElementById('summary');
  if (!box) return;

  const counts = countSummary(1);
  const gMe  = Math.floor(gold[1] || 0);
  const inc  = income(1);                // Impôt seigneurial (terres + villes)
  const bd   = upkeepBreakdown(1);       // détail entretien (on l’utilise pour total)
  const upk  = +bd.total.toFixed(1);
  const net  = +(gMe + inc - upk).toFixed(1);
  const fmt  = (n)=> (n % 1 ? n.toFixed(1) : n);

  // Ennemis (affichage conditionnel)
  const enemies = [];
  for (let o=2; o<=TOTAL_PLAYERS; o++) enemies.push({ id:o-1, g: Math.floor(gold[o] || 0) });

  box.innerHTML = `
    <ul class="sum-list">
      <li class="sum-item"><span>Fortune actuelle</span><b>${fmt(gMe)}</b></li>
      <li class="sum-item"><span>Impôt seigneurial</span><b class="pos">+${fmt(inc)}</b></li>
      <li class="sum-item"><span>Frais d'entretien</span><b class="neg">−${fmt(upk)}</b></li>
      <li class="sum-item"><span>Solde pour l'année prochaine</span><b>${fmt(net)}</b></li>
    </ul>

    <div class="sum-title">Armée</div>
    <ul class="sum-list">
      <li class="sum-item"><span>Fermier</span><b>${counts.units[1]} <span style="opacity:.8">(-${fmt(bd.byUnit[1])})</span></b></li>
      <li class="sum-item"><span>Milice</span><b>${counts.units[2]} <span style="opacity:.8">(-${fmt(bd.byUnit[2])})</span></b></li>
      <li class="sum-item"><span>Soldat</span><b>${counts.units[3]} <span style="opacity:.8">(-${fmt(bd.byUnit[3])})</span></b></li>
    </ul>

    <div class="sum-title">Flotte</div>
    <ul class="sum-list">
      <li class="sum-item"><span>Sloop</span><b>${counts.ships.sloop} <span style="opacity:.8">(-${fmt(bd.byShip.sloop)})</span></b></li>
      <li class="sum-item"><span>Brigantin</span><b>${counts.ships.brig} <span style="opacity:.8">(-${fmt(bd.byShip.brig)})</span></b></li>
      <li class="sum-item"><span>Galion</span><b>${counts.ships.galleon} <span style="opacity:.8">(-${fmt(bd.byShip.galleon)})</span></b></li>
    </ul>

    <div class="sum-title">Ennemi</div>
    <ul class="sum-list">
      <li class="sum-item"><span>Nombre d'ennemis</span><b>${enemies.length}</b></li>
      ${enemies.map(e => `
        <li class="sum-item"><span>Or présumé IA ${e.id}</span><b>${e.g}</b></li>
      `).join('')}
    </ul>
  `;
}

function isEnemy(a,b){ if(a===b) return false; if(AI_ALLIED&&a>1&&b>1) return false; return true; }
function beats(att,def){ if(att===def) return 0; return (att>def)?1:-1; }

function moveCostUnit(type, from, to, owner){
  if (!to) return Infinity;
  // On interdit seulement la tour ennemie ; la ville est autorisée
  if (to.structure === 'tower' && isEnemy(owner, to.owner)) return Infinity;
  if (to.terrain === 'shallow' || to.terrain === 'deep') return Infinity;
  if (to.terrain === 'forest'){
    if (type === 1 || type === 2) return 2;
    return Infinity;
  }
  return 1;
}

function passableForUnit(from, to, owner, type){
  if (!to) return false;
  if (to.structure === 'tower' && isEnemy(owner, to.owner)) return false; // ville OK
  if (to.terrain === 'shallow' || to.terrain === 'deep') return false;
  if (to.terrain === 'forest' && !(type === 1 || type === 2)) return false;
  if (to.unit && !isEnemy(owner, to.unit.owner) && to.unit.type !== type) return false;
  return true;
}

function passableForShip(from,to,owner,kind){
  if(!to) return false;
  if(to.ship) return false;
  if(to.structure==='tower'&&isEnemy(owner,to.owner)) return false;
  const rule=SHIPS[kind].water;
  if(rule==='shallow'&&to.terrain!=='shallow') return false;
  if(rule==='both'&&!(to.terrain==='shallow'||to.terrain==='deep')) return false;
  return true;
}

function reachableFrom(x, y, kind, param){
  const start = cell(x, y);
  const out = [];

  if (kind === 'ship'){
    const maxStep = SHIPS[start.ship.kind].move;
    const seen = new Map();
    const q = [[x, y, 0]];
    seen.set(idx(x,y), 0);
    while (q.length){
      const [cx, cy, st] = q.shift();
      const here = cell(cx, cy);
      for (const [nx, ny] of neighbors(cx, cy)){
        const there = cell(nx, ny);
        if (st + 1 > maxStep) continue;
        if (!passableForShip(here, there, start.ship.owner, start.ship.kind)) continue;
        const k = idx(nx, ny);
        if (seen.has(k) && seen.get(k) <= st + 1) continue;
        seen.set(k, st + 1);
        out.push([nx, ny]);
        q.push([nx, ny, st + 1]);
      }
    }
    return out;
  }

  const type   = start.unit.type;
  const owner  = start.unit.owner;
  const budget = UNITS[type].move;
  const dist = new Map();
  const open = [];
  const popMin = (arr) => { let k=0; for(let i=1;i<arr.length;i++) if(arr[i][2]<arr[k][2]) k=i; return arr.splice(k,1)[0]; };
  dist.set(idx(x,y), 0);
  open.push([x, y, 0]);

  while (open.length){
    const [cx, cy, costHere] = popMin(open);
    const here = cell(cx, cy);
    for (const [nx, ny] of neighbors(cx, cy)){
      const there = cell(nx, ny);
      if (!there) continue;
      if (!passableForUnit(here, there, owner, type)) continue;
      if (there.owner !== owner){
        if (there.owner === 0){
          if (!canAnnex(owner, nx, ny)) continue;
        } else if (isEnemy(owner, there.owner)){
          if (!canAnnex(owner, nx, ny)) continue;
        }
      }
      const step = moveCostUnit(type, here, there, owner);
      if (step === Infinity) continue;
      const newCost = costHere + step;
      if (newCost > budget) continue;
      const k = idx(nx, ny);
      if (dist.has(k) && dist.get(k) <= newCost) continue;
      dist.set(k, newCost);
      out.push([nx, ny]);
      const stopHere = (there.unit && isEnemy(owner, there.unit.owner)) || (there.owner > 0 && isEnemy(owner, there.owner));
      if (!stopHere){
        open.push([nx, ny, newCost]);
      }
    }
  }
  return out;
}

function canAnnex(owner,x,y){ return neighbors(x,y).some(([nx,ny])=>cell(nx,ny)?.owner===owner); }

function enemyHiddenForPlayer(t){
  if(!t) return false;
  const hasEnemy=(t.unit&&isEnemy(1,t.unit.owner))||(t.structure!=='none'&&isEnemy(1,t.owner));
  if(!hasEnemy) return false;
  if(t.terrain!=='forest') return false;
  for(const c of S){ if(c.unit&&c.unit.owner===1){ if(hexDist(c,t)<=CAMO_RANGE) return false; } }
  return true;
}

function ownedUnitsOfType(owner,type){let n=0; for(const c of S) if(c.unit&&c.unit.owner===owner&&c.unit.type===type) n+=(c.unit.level||1); return n;}
function totalUnitLevels(owner){
  let n = 0;
  for (const c of S) if (c.unit && c.unit.owner === owner) n += (c.unit.level || 1);
  return n;
}
function recruitCost(type, owner){
  const base = UNITS[type].cost;
  const sameType = ownedUnitsOfType(owner, type); // en "niveaux"
  const all = totalUnitLevels(owner);
  // +1 tous les 2 niveaux du même type, +1 tous les 6 niveaux au total
  return base + Math.floor(sameType / 2) + Math.floor(all / 6);
}

function upgradeCost(fromType, toType){
  if (fromType===1 && toType===2) return 2;
  if (fromType===2 && toType===3) return 3;
  return 99;
}

function ownedShips(owner){ let n=0; for(const c of S) if(c.ship && c.ship.owner===owner) n++; return n; }
function ownedShipsOfKind(owner, kind){ let n=0; for(const c of S) if(c.ship && c.ship.owner===owner && c.ship.kind===kind) n++; return n; }
function shipBuildCost(kind, owner){
  const base = SHIPS[kind].cost;
  return base + 2*ownedShipsOfKind(owner, kind) + Math.floor(ownedShips(owner)/2);
}

let spawnMode = null;
let spawnChoices = [];

function citySpawnCandidates(x,y,type,owner=1){
  return neighbors(x,y).filter(([nx,ny])=>{
    const t = cell(nx,ny);
    if (!t) return false;
    if (t.structure !== 'none') return false;
    if (t.unit || t.ship) return false;
    if (!(t.terrain==='land' || t.terrain==='forest')) return false;
    if (!passableForUnit({x,y}, t, owner, type)) return false;
    if (t.owner === owner) return true;
    if (t.owner === 0) return canAnnex(owner, nx, ny);
    return false;
  });
}

function beginSpawnFromCity(x,y,type){
  const cost = recruitCost(type,1);
  if ((gold[1]||0) < cost){ addLog("Pas assez d'or", `Coût ${cost} or`, 1); return; }
  const spots = citySpawnCandidates(x,y,type,1);
  if (!spots.length){
    addLog("Pas d'emplacement de camp à proximité.","Aucune case terrestre libre/annexable autour de la ville pour former une nouvelle armée.", 1);
    return;
  }
  // ✨ Toujours proposer (même s'il n'y a qu'une case)
  spawnMode   = { type, cost, spots };
  spawnChoices = spots.slice();
  addLog("Choisis une case de déploiement", "Clique sur une des cases surlignées autour de la ville.", 1);
  drawOverlay();
}

function spawnUnit(x,y,u,moved=true){
  const c = cell(x,y);
  if (!c || c.ship) return false;
  const placeHere = (t)=>{ 
    if (t.unit || t.ship) return false;
    t.unit = ensureHP({ owner:u.owner, type:u.type, level:u.level||1, moved });
    t.owner = u.owner;
    return true;
  };
  if (c.structure !== 'none'){
    const cand = neighbors(x,y).find(([nx,ny])=>{
      const t = cell(nx,ny);
      if (!t) return false;
      if (t.structure !== 'none') return false;
      if (!(t.terrain==='land' || t.terrain==='forest')) return false;
      if (t.unit || t.ship) return false;
      return (t.owner === u.owner) || canAnnex(u.owner, nx, ny);
    });
    if (!cand) return false;
    const [nx,ny] = cand;
    return placeHere(cell(nx,ny));
  }
  if (!(c.terrain==='land' || c.terrain==='forest')) return false;
  if (c.unit) return false;
  return placeHere(c);
}

function unitName(t){ return (UNITS[t]?.name||'Unité').toLowerCase(); }

function moveUnit(sx, sy, dx, dy, _viaReach=false){
  const src = cell(sx, sy), dst = cell(dx, dy);
  if (!src?.unit || src.unit.moved || src.unit.owner !== 1) return;
  if (dst?.structure !== 'none' && dst?.structure !== 'city') return;
  if (moveCostUnit(src.unit.type, src, dst, 1) === Infinity) return;

  // Fusion alliée (même type)
  if (dst?.unit && !isEnemy(1, dst.unit.owner) && dst.unit.type === src.unit.type){
    ensureHP(src.unit); ensureHP(dst.unit);
  const newLevel = (dst.unit.level||1) + (src.unit.level||1);
  const maxPerUnit = baseHP(dst.unit.type);
  const newMax = newLevel * maxPerUnit;

  // somme des PV actuels des deux piles, bornée au max
  const summedHP = Math.min(newMax, (dst.unit.hp||dst.unit.hpMax) + (src.unit.hp||src.unit.hpMax));

  dst.unit.level = newLevel;
  dst.unit.hpMax = newMax;
  dst.unit.hp    = summedHP;
  dst.unit.moved = true;

  src.unit = null;
  dst.owner = 1;

    addLog(`Fusion en ${dx},${dy}`, `Pile de ${UNITS[dst.unit.type].name} ×${dst.unit.level}`, 1);
    return;
  }

  // Combat contre ennemi sur la case
  if (dst?.unit && isEnemy(1, dst.unit.owner)){
    if (!canAnnex(1, dx, dy)){ addLog("Impossible d'annexer", "Il faut être adjacent à ton territoire.", 1); return; }

    ensureHP(src.unit); ensureHP(dst.unit);

    const attType = src.unit.type;
    let defEff = dst.unit.type;

  // Bonus défensif si le défenseur est dans SA ville
  if (dst.structure === 'city' && dst.owner === dst.unit.owner) defEff += DEF_BONUS_CITY;

  // Résolution : att > def => victoire ; att == def => victoire (perte 50%); att < def => défaite
  if (attType > defEff){
    // Attaquant gagne, applique son malus de victoire
    applyVictoryDamageToUnit(src.unit, attType, dst.unit.type);
    dst.unit = { ...src.unit, moved: true };
    dst.owner = 1;
    src.unit = null;
    addLog(`Victoire en ${dx},${dy}`, `Ton ${unitName(attType)} l'emporte.`, 1);
    } else if (attType === defEff){
      // Égalité -> l'attaquant gagne mais tombe à 50% de ses PV max
      src.unit.hp = Math.max(1, Math.ceil(src.unit.hpMax * 0.5));
      dst.unit = { ...src.unit, moved: true };
      dst.owner = 1;
      src.unit = null;
      addLog(`Victoire en ${dx},${dy}`, `Match de rang : tu gagnes mais -50% PV.`, 1);
    } else {
      // Défaite de l'attaquant
      src.unit = null;
      addLog(`Défaite en ${dx},${dy}`, `Ton ${unitName(attType)} est détruit.`, 1);
    }
    return;
  }


  // Ville : capture/entrée
  if (dst.structure === 'city'){
    const wasEnemy = isEnemy(1, dst.owner);
    if (wasEnemy && !canAnnex(1, dx, dy)){ addLog("Impossible d'annexer", "Il faut être adjacent à ton territoire.", 1); return; }
    if (wasEnemy) dst.owner = 1;
    dst.unit = { ...src.unit, moved: true };
    src.unit = null;
    addLog(wasEnemy ? 'Ville capturée' : 'Entrée dans la ville', `En ${dx},${dy}`, 1);
    return;
  }

  // Case normale
  if (dst.owner !== 1 && !canAnnex(1, dx, dy)){
    addLog("Impossible d'annexer", "Il faut être adjacent à ton territoire.", 1);
    return;
  }
  dst.unit = { ...src.unit, moved: true };
  dst.owner = 1;
  src.unit = null;
  addLog(`Prise de ${dx},${dy}`, 'La case passe sous ton contrôle.', 1);
}

function moveUnitAI(sx, sy, dx, dy, owner){
  const src = cell(sx, sy), dst = cell(dx, dy);
  if (!src?.unit || src.unit.moved || src.unit.owner !== owner) return;
  if (dst?.structure === 'tower' && isEnemy(owner, dst.owner)) return;
  if (moveCostUnit(src.unit.type, src, dst, owner) === Infinity) return;

  // Fusion alliée (même type)
  if (dst?.unit && !isEnemy(owner, dst.unit.owner) && dst.unit.type === src.unit.type){
    ensureHP(src.unit); ensureHP(dst.unit);
    const newLevel = (dst.unit.level||1) + (src.unit.level||1);
    const maxPerUnit = baseHP(dst.unit.type);
    const newMax = newLevel * maxPerUnit;
    const summedHP = Math.min(newMax, (dst.unit.hp||dst.unit.hpMax) + (src.unit.hp||src.unit.hpMax));
    dst.unit.level = newLevel;
    dst.unit.hpMax = newMax;
    dst.unit.hp    = summedHP;
    dst.unit.moved = true;
    src.unit = null;
    dst.owner = owner;
    return;
  }

  // Combat
  if (dst?.unit && isEnemy(owner, dst.unit.owner)){
    if (!canAnnex(owner, dx, dy)) return;

    ensureHP(src.unit); ensureHP(dst.unit);
    const attType = src.unit.type;
    let defEff = dst.unit.type;
    if (dst.structure === 'city' && dst.owner === dst.unit.owner) defEff += DEF_BONUS_CITY;

    if (attType > defEff){
      applyVictoryDamageToUnit(src.unit, attType, dst.unit.type);
      dst.unit = { ...src.unit, moved:true };
      dst.owner = owner;
      src.unit = null;
    } else if (attType === defEff){
      src.unit.hp = Math.max(1, Math.ceil(src.unit.hpMax * 0.5));
      dst.unit = { ...src.unit, moved:true };
      dst.owner = owner;
      src.unit = null;
    } else {
      src.unit = null;
    }
    return;
  }

  // Ville : capture/entrée
  if (dst.structure === 'city'){
    const wasEnemy = isEnemy(owner, dst.owner);
    if (wasEnemy && !canAnnex(owner, dx, dy)) return;
    if (wasEnemy) dst.owner = owner;
    dst.unit = { ...src.unit, moved:true };
    src.unit = null;
    return;
  }

  // Case normale
  if (dst.owner !== owner && !canAnnex(owner, dx, dy)) return;
  dst.unit = { ...src.unit, moved:true };
  dst.owner = owner;
  src.unit = null;
}

function moveShip(sx, sy, dx, dy){
  const src = cell(sx, sy), dst = cell(dx, dy);
  if (!src?.ship || src.ship.moved || src.ship.owner !== 1 || dst?.ship) return;
  if (!passableForShip(src, dst, 1, src.ship.kind)) return;
  dst.ship = { ...src.ship, moved: true };
  src.ship = null;
}
function moveShipAI(sx, sy, dx, dy, owner){
  const src = cell(sx, sy), dst = cell(dx, dy);
  if (!src?.ship || src.ship.moved || src.ship.owner !== owner || dst?.ship) return;
  if (!passableForShip(src, dst, owner, src.ship.kind)) return;
  dst.ship = { ...src.ship, moved: true }; src.ship = null;
}

function tryUpgradeAtCity(x,y,toTypeMaybe){
  const c = cell(x,y);
  if(!c || c.structure!=='city' || c.owner!==1 || !c.unit || c.unit.owner!==1){
    addLog("Aucune unité à améliorer dans la ville.", null, 1);
    return;
  }
  const from = c.unit.type;
  const to   = toTypeMaybe || (from===1?2:(from===2?3:3));
  if (from===3){ addLog("Déjà au rang maximum.", null, 1); return; }

  const cost = upgradeCost(from, to);
  if ((gold[1]||0) < cost){
    addLog("Pas assez d'or", `Coût ${cost} or`, 1);
    return;
  }

  const oldMax = ensureHP(c.unit).hpMax;
  const pct    = c.unit.hp / oldMax;

  gold[1] -= cost;
  c.unit.type  = to;
  c.unit.moved = true;

  const newMax = baseHP(c.unit.type) * (c.unit.level || 1);
  c.unit.hpMax = newMax;
  c.unit.hp    = Math.max(1, Math.round(newMax * pct));

  addLog(`Amélioration: ${UNITS[to].name}`, `En ${x},${y} (coût ${cost})`, 1);
  render();
}

const $ = id => document.getElementById(id);
const B = id => document.getElementById(id);

$('buildCity').onclick=()=>{
  if(!selected) return;
  const c=cell(selected.x,selected.y);
  const cc=cityCost(1);
  if((gold[1]||0)<cc || c?.structure!=='none' || c?.terrain!=='land') return;
  c.structure='city'; c.owner=1; gold[1]-=cc;
  addLog('Ville fondée',`En ${selected.x},${selected.y} (coût ${cc} or)`,1);
  render();
};
$('buildTower').onclick=()=>{
  if(!selected) return;
  const c=cell(selected.x,selected.y);
  if((gold[1]||0)<3 || c?.structure!=='none' || c?.terrain!=='land') return;
  c.structure='tower'; c.owner=1; gold[1]-=3;
  addLog('Tour bâtie',`En ${selected.x},${selected.y}`,1);
  render();
};

B('makeSloop').onclick   = ()=>beginShipBuild('sloop');
B('makeBrig').onclick    = ()=>beginShipBuild('brig');
B('makeGalleon').onclick = ()=>beginShipBuild('galleon');
B('loadShip').onclick    = ()=>loadShip();
B('disembark').onclick   = ()=>disembark();

$('recFarmer').onclick = ()=>{
  const s=selected; if(!s) return;
  const c = cell(s.x,s.y);
  if(!c || c.structure!=='city' || c.owner!==1) return;
  beginSpawnFromCity(s.x,s.y,1);
};
$('recMilitia').onclick = ()=>{
  const s=selected; if(!s) return;
  const c = cell(s.x,s.y);
  if(!c || c.structure!=='city' || c.owner!==1) return;
  beginSpawnFromCity(s.x,s.y,2);
};
$('recSoldier').onclick = ()=>{
  const s=selected; if(!s) return;
  const c = cell(s.x,s.y);
  if(!c || c.structure!=='city' || c.owner!==1) return;
  beginSpawnFromCity(s.x,s.y,3);
};

$('upFarmMil').onclick = ()=>{
  const s=selected; if(!s) return;
  const c = cell(s.x,s.y);
  if(!c || c.structure!=='city' || c.owner!==1) return;
  tryUpgradeAtCity(s.x,s.y,2);
};
$('upMilSold').onclick = ()=>{
  const s=selected; if(!s) return;
  const c = cell(s.x,s.y);
  if(!c || c.structure!=='city' || c.owner!==1) return;
  tryUpgradeAtCity(s.x,s.y,3);
};

function recruitLabel(type, cost){
  const u = UNITS[type];
  return `<span class="title">Recruter ${u.name}</span><span class="meta">Coût ${cost} · Loyer ${u.upkeep} · PM ${u.move}</span>`;
}

function capacityLeft(shipCellObj){
  const ship = shipCellObj.ship || shipCellObj;
  return SHIPS[ship.kind].cap - (ship.cargo?.reduce((a,u)=>a+(u.level||1),0) || 0);
}
function loadShip(){
  const s = selected && cell(selected.x,selected.y);
  if(!s?.ship || s.ship.moved || s.ship.owner!==1) return;
  if(!s.ship.cargo) s.ship.cargo=[];
  const capLeft = capacityLeft(s);
  const pos = neighbors(selected.x,selected.y).find(([nx,ny])=>{
    const t=cell(nx,ny);
    return t?.unit && t.unit.owner===1 && (t.unit.level||1) <= capLeft;
  });
  if(!pos){ addLog("Aucune unité admissible à embarquer (capacité insuffisante).", null, 1); return; }
  const [ux,uy]=pos; const u=cell(ux,uy);
  s.ship.cargo.push({...u.unit}); u.unit=null;
  addLog('Embarquement', `Depuis ${ux},${uy}`, 1);
  render();
}
function disembark(){
  const s = selected && cell(selected.x, selected.y);
  if(!s?.ship || s.ship.moved || s.ship.owner!==1 || !(s.ship.cargo && s.ship.cargo.length)) return;
  const spot = neighbors(selected.x, selected.y).find(([nx,ny])=>{
    const t=cell(nx,ny);
    return !!t && (t.terrain==='land' || t.terrain==='forest') && !t.unit
      && !(t.structure==='tower' && isEnemy(1,t.owner))
      && (t.owner===0 || canAnnex(1,nx,ny));
  });
  if(!spot){ addLog("Débarquement interdit : aucun emplacement valide (terre libre requise).", null, 1); return; }
  const [dx,dy]=spot; const t=cell(dx,dy);
  const u = s.ship.cargo.shift();
  t.unit = { ...u, moved:true }; t.owner = 1; s.ship.moved = true;
  addLog('Débarquement', `En ${dx},${dy}`, 1);
  render();
}

let shipBuildMode = null;
function shipBuildCandidates(ux,uy,kind,owner=1){
  const uCell = cell(ux,uy); if(!uCell) return [];
  const spots=[];
  for (const [nx,ny] of neighbors(ux,uy)){
    const t = cell(nx,ny);
    if (!t || t.ship) continue;
    if (!passableForShip(uCell, t, owner, kind)) continue;
    spots.push([nx,ny]);
  }
  return spots;
}
function beginShipBuild(kind){
  const sel = selected && cell(selected.x,selected.y);
  if(!sel || !sel.unit || sel.unit.owner!==1){
    addLog("Sélectionne d'abord une unité sur la côte.", null, 1);
    return;
  }
  const cost = shipBuildCost(kind, 1);
  if((gold[1]||0) < cost){ addLog("Pas assez d'or", `Coût ${cost} or`, 1); return; }
  const spots = shipBuildCandidates(selected.x, selected.y, kind, 1);
  if (!spots.length){
    addLog("Pas d'emplacement de mise à l'eau à proximité.", "Aucune case d'eau adjacente libre.", 1);
    return;
  }
  shipBuildMode = { kind, from:{x:selected.x,y:selected.y}, cost, spots };
  spawnChoices = spots.slice();
  addLog(`Choisis l'emplacement du ${SHIPS[kind].name}`, "Clique sur une case d'eau adjacente surlignée.", 1);
  drawOverlay();
}

function spawnSpotsAroundCity(x,y, owner, _type){
  const spots = [];
  for (const [nx,ny] of neighbors(x,y)){
    const t = cell(nx,ny);
    if (!t) continue;
    if (!(t.terrain==='land' || t.terrain==='forest')) continue;
    if (t.structure !== 'none') continue;
    if (t.unit || t.ship) continue;
    if (t.owner !== owner && !canAnnex(owner, nx, ny)) continue;
    spots.push([nx,ny]);
  }
  return spots;
}

function updateActionsPanel(){
  const sel=selected?cell(selected.x,selected.y):null, myTurn=(turn===1);
  const cc=cityCost(1); const bc=document.getElementById('buildCity'); bc.textContent=`Construire Ville (${cc} or)`;
  const onUnit = myTurn && sel && selected.kind==='unit' && sel.unit && !sel.unit.moved;
  const sSpots = onUnit ? shipBuildCandidates(selected.x,selected.y,'sloop',1).length    : 0;
  const bSpots = onUnit ? shipBuildCandidates(selected.x,selected.y,'brig',1).length     : 0;
  const gSpots = onUnit ? shipBuildCandidates(selected.x,selected.y,'galleon',1).length  : 0;
  const costS = shipBuildCost('sloop',   1);
const costB = shipBuildCost('brig',    1);
const costG = shipBuildCost('galleon', 1);

  B('makeSloop').textContent   = `Sloop 1 mât (${costS} or)`;
  B('makeBrig').textContent    = `Brigantin 2 mâts (${costB} or)`;
  B('makeGalleon').textContent = `Galion 3 mâts (${costG} or)`;

  B('makeSloop').disabled   = !(onUnit && sSpots>0 && (gold[1]||0)>=costS);
  B('makeBrig').disabled    = !(onUnit && bSpots>0 && (gold[1]||0)>=costB);
  B('makeGalleon').disabled = !(onUnit && gSpots>0 && (gold[1]||0)>=costG);

  const ownEmptyLand=myTurn&&sel&&selected.kind==='empty'&&sel.terrain==='land'&&sel.structure==='none';
  B('buildCity').disabled=!(ownEmptyLand&&(gold[1]||0)>=cc);
  B('buildTower').disabled=!(ownEmptyLand&&(gold[1]||0)>=3);
  const onShip=myTurn&&sel&&selected.kind==='ship'&&sel.ship&&!sel.ship.moved&&sel.ship.owner===1;
  B('loadShip').disabled=!(onShip && capacityLeft(sel)>0 && neighbors(selected.x,selected.y).some(([nx,ny])=>{const t=cell(nx,ny);return t?.unit && t.unit.owner===1 && (t.unit.level||1)<=capacityLeft(sel);} ) );
  B('disembark').disabled = !(onShip && (sel.ship.cargo?.length||0)>0 && neighbors(selected.x,selected.y).some(([nx,ny])=>{
    const t = cell(nx,ny);
    return !!t && (t.terrain==='land' || t.terrain==='forest') && !t.unit && !(t.structure==='tower' && isEnemy(1,t.owner)) && (t.owner===0 || canAnnex(1,nx,ny));
  }));
  const onCity = myTurn && sel &&
  ((sel.structure==='city' && sel.owner===1) || false);
  const cF = recruitCost(1,1), cM = recruitCost(2,1), cS = recruitCost(3,1);
  document.getElementById('recFarmer').innerHTML  = recruitLabel(1, cF);
  document.getElementById('recMilitia').innerHTML = recruitLabel(2, cM);
  document.getElementById('recSoldier').innerHTML = recruitLabel(3, cS);
  const spots = onCity ? spawnSpotsAroundCity(selected.x,selected.y,1,0) : [];
  const anySpot = spots.length>0;
  B('recFarmer').disabled  = !(onCity && anySpot && (gold[1]||0)>=cF);
  B('recMilitia').disabled = !(onCity && anySpot && (gold[1]||0)>=cM);
  B('recSoldier').disabled = !(onCity && anySpot && (gold[1]||0)>=cS);
  let canUpFM=false, canUpMS=false, labFM='Améliorer Fermier → Milice', labMS='Améliorer Milice → Soldat';
  if(onCity && sel.unit && sel.unit.owner===1){
    if(sel.unit.type===1){ const price=upgradeCost(1,2); labFM += ` (${price} or)`; canUpFM=(gold[1]||0)>=price; }
    if(sel.unit.type===2){ const price=upgradeCost(2,3); labMS += ` (${price} or)`; canUpMS=(gold[1]||0)>=price; }
  }
  document.getElementById('upFarmMil').textContent = labFM;
  document.getElementById('upMilSold').textContent = labMS;
  B('upFarmMil').disabled = !(onCity && sel?.unit?.owner===1 && sel.unit.type===1 && canUpFM);
  B('upMilSold').disabled = !(onCity && sel?.unit?.owner===1 && sel.unit.type===2 && canUpMS);
  const ids = ['buildCity','buildTower','recFarmer','recMilitia','recSoldier','upFarmMil','upMilSold','makeSloop','makeBrig','makeGalleon','loadShip','disembark'];
  const anyVisible = ids.some(id => !B(id).disabled);
  let msg = document.getElementById('actionsMsg');
  if (!msg){
    msg = document.createElement('div');
    msg.id = 'actionsMsg';
    msg.className = 'hint-msg';
    document.getElementById('actions').appendChild(msg);
  }
  msg.style.display = anyVisible ? 'none' : 'block';
  if (!anyVisible){
    msg.textContent = selected ? "Aucune action possible ici." : "Clique sur un territoire, une ville ou une unité pour accéder à ses actions.";
  }
}

function drawTerrain(){
  const Wpx=STEP_X*(W-1)+HEX_W, Hpx=STEP_Y*(H-1)+HEX_H+HEX_H/2;
  WpxCached=Wpx; HpxCached=Hpx;
  stageEl.style.width=Wpx+'px'; stageEl.style.height=Hpx+'px';
  terrain.setAttribute('width',Wpx); terrain.setAttribute('height',Hpx); terrain.setAttribute('viewBox',`0 0 ${Wpx} ${Hpx}`); terrain.innerHTML='';
  const defs=document.createElementNS(terrain.namespaceURI,'defs');
  const waves=(id,stroke,opacity)=>{const p=document.createElementNS(terrain.namespaceURI,'pattern');p.id=id;p.setAttribute('patternUnits','userSpaceOnUse');p.setAttribute('width','12');p.setAttribute('height','10');const path=document.createElementNS(terrain.namespaceURI,'path');path.setAttribute('d','M0 6 Q3 8 6 6 T12 6');path.setAttribute('fill','none');path.setAttribute('stroke',stroke);path.setAttribute('stroke-width','1.2');path.setAttribute('opacity',opacity);p.appendChild(path);defs.appendChild(p);};
  waves('wavesShallow','#2b6da3',0.40); waves('wavesDeep','#9ecbff',0.22);
  const tree=document.createElementNS(terrain.namespaceURI,'pattern'); tree.id='treePattern'; tree.setAttribute('patternUnits','userSpaceOnUse'); tree.setAttribute('width','14'); tree.setAttribute('height','14');
  const g=document.createElementNS(terrain.namespaceURI,'g'); const tri=document.createElementNS(terrain.namespaceURI,'path'); tri.setAttribute('d','M7 2 L2 9 L12 9 Z'); tri.setAttribute('fill','rgba(34,85,34,.55)');
  const trunk=document.createElementNS(terrain.namespaceURI,'path'); trunk.setAttribute('d','M7 9 L7 12'); trunk.setAttribute('stroke','rgba(60,40,20,.7)'); trunk.setAttribute('stroke-width','2'); g.appendChild(tri); g.appendChild(trunk); tree.appendChild(g); defs.appendChild(tree);
  terrain.appendChild(defs);

  const gT=document.createElementNS(terrain.namespaceURI,'g'); terrain.appendChild(gT);
  for (let y=0; y<H; y++) for (let x=0; x<W; x++){
    const c = cell(x,y);
    if (!c) continue;
    const {cx,cy} = hexCenter(x,y);
    const poly=document.createElementNS(terrain.namespaceURI,'polygon');
    poly.setAttribute('points', svgHexPoints(cx,cy));
    let fill;
    if (c.terrain==='deep')    fill=getComputedStyle(document.documentElement).getPropertyValue('--deep').trim();
    else if (c.terrain==='shallow') fill=getComputedStyle(document.documentElement).getPropertyValue('--shallow').trim();
    else {
      const base=regionColor(c.owner||0);
      fill=(c.terrain==='forest') ? mix(base,'#6cab6c',0.22) : base;
    }
    poly.setAttribute('fill',fill);
    poly.setAttribute('stroke',fill);
    poly.setAttribute('stroke-width','1');
    poly.setAttribute('stroke-linejoin','round');
    poly.setAttribute('vector-effect','non-scaling-stroke');
    poly.setAttribute('shape-rendering','geometricPrecision');
    gT.appendChild(poly);
    if (c.terrain==='shallow' || c.terrain==='deep'){
      const top=document.createElementNS(terrain.namespaceURI,'polygon');
      top.setAttribute('points', svgHexPoints(cx,cy,0.992));
      top.setAttribute('fill', `url(#${c.terrain==='shallow'?'wavesShallow':'wavesDeep'})`);
      top.setAttribute('opacity','1'); gT.appendChild(top);
    } else if (c.terrain==='forest'){
      const ov=document.createElementNS(terrain.namespaceURI,'polygon');
      ov.setAttribute('points', svgHexPoints(cx,cy,0.992));
      ov.setAttribute('fill','url(#treePattern)');
      ov.setAttribute('opacity','1'); gT.appendChild(ov);
    }
    if (c.terrain === 'land'){
      const r = hash(c.x*13.3, c.y*7.7);
      if (r < 0.28){
        const grp = document.createElementNS(terrain.namespaceURI,'g');
        grp.setAttribute('opacity','0.35');
        const jitterX = (hash(c.x*51.1, c.y*27.9)-0.5) * (HEX_W*0.20);
        const jitterY = (hash(c.x*17.2, c.y*39.8)-0.5) * (HEX_H*0.20);
        grp.setAttribute('transform', `translate(${cx + jitterX},${cy + jitterY})`);
        const rock = (sx,sy,sz)=>{
          const p=document.createElementNS(terrain.namespaceURI,'path');
          p.setAttribute('d', `M ${sx-sz} ${sy} q ${sz*0.9} ${-sz*0.8} ${sz*2} 0 q ${-sz*0.8} ${sz*0.9} ${-sz*2} 0 Z`);
          p.setAttribute('fill', '#7f7362'); p.setAttribute('stroke', '#a49786'); p.setAttribute('stroke-width', '0.6');
          grp.appendChild(p);
        };
        rock(0, 0, 2.0); if (r < 0.18) rock(6, 3, 1.3); if (r < 0.10) rock(-5, 3, 1.1);
        gT.appendChild(grp);
      }
    }
  }
  overlay.setAttribute('width',Wpx); overlay.setAttribute('height',Hpx); overlay.setAttribute('viewBox',`0 0 ${Wpx} ${Hpx}`);
  gridEl.style.width=Wpx+'px'; gridEl.style.height=Hpx+'px';
}

function drawOverlay(){
  overlay.innerHTML='';
  const gTheo=document.createElementNS(overlay.namespaceURI,'g'),
        gReach=document.createElementNS(overlay.namespaceURI,'g');
  overlay.appendChild(gTheo); overlay.appendChild(gReach);
  const drawList=(arr,group,fill)=>{
    for(const [x,y] of arr){
      const {cx,cy}=hexCenter(x,y);
      const p=document.createElementNS(overlay.namespaceURI,'polygon');
      p.setAttribute('points',svgHexPoints(cx,cy,0.985));
      p.setAttribute('fill',fill); p.setAttribute('stroke',fill);
      p.setAttribute('stroke-width','1'); p.setAttribute('stroke-linejoin','round');
      group.appendChild(p);
    }
  };
  drawList(reachTheo,gTheo,getComputedStyle(document.documentElement).getPropertyValue('--theo-fill').trim());
  drawList(reach,gReach,getComputedStyle(document.documentElement).getPropertyValue('--reach-fill').trim());
  if (spawnChoices && spawnChoices.length){
    drawList(spawnChoices, gReach, 'rgba(255,204,0,0.28)');
  }
}

function applyView(){
  worldEl.style.transformOrigin='0 0';
  worldEl.style.transform=`translate(${panX}px, ${panY}px) scale(${zoom})`;
  const zl=document.getElementById('zoomLabel'); if(zl) zl.textContent=Math.round(zoom*100)+'%';
}
function centerBoard(){
  const vw=boardEl.clientWidth, vh=boardEl.clientHeight;
  const targetW=WpxCached*zoom, targetH=HpxCached*zoom;
  panX=Math.floor((vw-targetW)/2);
  panY=Math.floor((vh-targetH)/2);
  applyView();
}

function render(){
  drawTerrain();
  if (selected) {
    if (!inb(selected.x, selected.y)) { selected = null; }
    else {
      const cSel = cell(selected.x, selected.y);
      const ok =
        selected.kind==='unit'  ? !!cSel?.unit :
        selected.kind==='ship'  ? !!cSel?.ship :
        selected.kind==='city'  ? (cSel?.structure==='city' && cSel?.owner===1) :
        selected.kind==='empty' ? (!!cSel && !cSel.unit && !cSel.ship) : false;
      if (!ok) selected = null;
    }
  }
  if (S.length !== W * H){
    overlay.innerHTML = '';
    gridEl.innerHTML  = '';
    updateHUD();
    applyView();
    return;
  }
  reach = []; reachTheo = [];
  if (selected){
    const c = cell(selected.x, selected.y);
    if (selected.kind === 'unit' && c?.unit){
      reachTheo = reachableFrom(selected.x, selected.y, 'unit', c.unit.type);
      reach     = c.unit.moved ? [] : reachTheo.slice();
    }
    if (selected.kind === 'ship' && c?.ship){
      reachTheo = reachableFrom(selected.x, selected.y, 'ship', c.ship.kind);
      reach     = c.ship.moved ? [] : reachTheo.slice();
    }
  }
  drawOverlay();
  gridEl.innerHTML = '';
  for (let y=0; y<H; y++) for (let x=0; x<W; x++){
    const c = cell(x,y);
    if (!c) continue;
    const {cx,cy} = hexCenter(x,y);
    const d = document.createElement('div');
    d.className = 'hex';
    d.style.left = cx+'px'; d.style.top = cy+'px';
    d.style.width = HEX_W+'px'; d.style.height = HEX_H+'px';
    d.style.clipPath='polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)';
    d.dataset.x = x; d.dataset.y = y;
    d.addEventListener('click', onCellClick);// rendre la case focusable + action avec Entrée/Espace
    d.tabIndex = 0;
    d.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter' || ev.key === ' '){
        onCellClick({ currentTarget: d });
        ev.preventDefault();
      }
    });
    const isLand = (c.terrain === 'land' || c.terrain === 'forest');
    const hasFrontier = isLand && neighbors(x,y).some(([nx,ny])=>{
      const n = cell(nx,ny);
      if (!n) return false;
      const nLand = (n.terrain === 'land' || n.terrain === 'forest');
      return nLand && n.owner !== c.owner;
    });
    if (hasFrontier){
      d.classList.add('frontier');
      if (c.owner === 1) d.classList.add('owned1');
      else if (c.owner === 2) d.classList.add('owned2');
    }
    if (selected && selected.x===x && selected.y===y) d.classList.add('selected');
    const hidden = enemyHiddenForPlayer(c);
    if (c.structure === 'city' && !hidden){
      const v=document.createElement('div'); v.className='city';
      if (c.owner===1 && c.terrain==='forest') v.classList.add('camo');
      v.appendChild(svgCastle()); d.appendChild(v);
      const h=document.createElement('div'); h.className='hint'; h.textContent='+2'; d.appendChild(h);
    }
    if (c.structure === 'tower' && !hidden){
      const t=document.createElement('div'); t.className='tower';
      if (c.owner===1 && c.terrain==='forest') t.classList.add('camo');
      t.appendChild(svgRook()); d.appendChild(t);
    }
    if (c.unit && !hidden){
      ensureHP(c.unit);

      // Badge
      const u = document.createElement('div');
      u.className = 'badge';
      u.style.background = ownerColor(c.unit.owner);
      if (c.unit.owner===1 && c.terrain==='forest') u.classList.add('camo');
      u.appendChild(svgIconUnit(c.unit.type));
      d.appendChild(u);

      // Barre de vie
      const hpWrap = document.createElement('div');
      hpWrap.className = 'hpbar';
      const hpFill = document.createElement('div');
      hpFill.className = 'hpfill';
      const ratio = Math.max(0, Math.min(1, c.unit.hp / c.unit.hpMax));
      hpFill.style.width = Math.round(ratio * 100) + '%';
      hpWrap.appendChild(hpFill);
      d.appendChild(hpWrap);
    }

    if (c.ship){
      const s=document.createElement('div'); s.className='ship';
      s.style.background=ownerColor(c.ship.owner);
      s.appendChild(svgShip(c.ship.kind));
      const h=document.createElement('div'); h.className='hint';
      h.textContent=`${(c.ship.cargo?.reduce((a,u)=>a+(u.level||1),0)||0)}/${SHIPS[c.ship.kind].cap}`;
      d.appendChild(s); d.appendChild(h);
    }
    gridEl.appendChild(d);
  }
  updateHUD();
  updateActionsPanel();
  renderSummary();
}

function svgIconUnit(type){const s=elSVG('0 0 24 24'); if(type===1){path(s,'M6 3 L6 15',2.6);path(s,'M3 7 L9 7',2.6);path(s,'M9 4 L9 8',2.6);path(s,'M6 15 L6 21',2.6);path(s,'M12 14 C12 12, 15 12, 15 14 C15 16, 12 16,12 14',2.2);return s;} if(type===2){circle(s,12,12,5.5,2.6);path(s,'M4 20 L20 4',2.6);return s;} path(s,'M6 10 C6 6, 18 6, 18 10',2.6);path(s,'M6 10 L18 10',2.6);path(s,'M12 11 L12 20',2.6);path(s,'M9 20 L15 20',2.6);return s;}
function svgShip(kind){const s=elSVG('0 0 48 28'); pathC(s,'M4 18 L44 18 L38 24 L10 24 Z',1.5,'#444'); line(s,20,6,20,18,2); if(kind!=='sloop') line(s,28,6,28,18,2); return s;}
function svgCastle(){const s=elSVG('0 0 24 16','castle'); pathW(s,'M2 6 L22 6 L22 14 L2 14 Z',1.6); pathW(s,'M2 6 L2 3 L5 3 L5 6 M8 6 L8 3 L11 3 L11 6 M14 6 L14 3 L17 3 L17 6 M20 6 L20 3 L22 3 L22 6',1.6); pathW(s,'M10 14 L10 10 L14 10 L14 14',1.6); return s;}
function svgRook(){const s=elSVG('0 0 24 24'); pathFill(s,'M5 20 L19 20 L19 18 L17 16 L17 11 L18 10 L18 7 L15 7 L15 9 L12 9 L12 7 L9 7 L9 9 L6 9 L6 7 L5 7 L5 10 L6 11 L6 16 L5 18 Z','#777','#555',1.2); return s;}
function elSVG(vb,cls){const s=document.createElementNS('http://www.w3.org/2000/svg','svg'); s.setAttribute('viewBox',vb); s.classList.add('icon'); if(cls) s.classList.add(cls); return s;}
function path(s,d,sw=2){const p=document.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d',d); p.setAttribute('fill','none'); p.setAttribute('stroke','#fff'); p.setAttribute('stroke-width',sw); p.setAttribute('stroke-linecap','round'); p.setAttribute('stroke-linejoin','round'); s.appendChild(p);}
function pathW(s,d,sw=2){const p=document.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d',d); p.setAttribute('fill','none'); p.setAttribute('stroke','#fff'); p.setAttribute('stroke-width',sw); p.setAttribute('stroke-linecap','round'); p.setAttribute('stroke-linejoin','round'); s.appendChild(p);}
function pathC(s,d,sw=2,fill='#444'){const p=document.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d',d); p.setAttribute('fill',fill); p.setAttribute('stroke','#eee'); p.setAttribute('stroke-width',sw); p.setAttribute('stroke-linejoin','round'); s.appendChild(p);}
function pathFill(s,d,fill='#777',stroke='#555',sw=1){const p=document.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d',d); p.setAttribute('fill',fill); p.setAttribute('stroke',stroke); p.setAttribute('stroke-width',sw); p.setAttribute('stroke-linejoin','round'); s.appendChild(p);}
function circle(s,cx,cy,r,sw=2){const c=document.createElementNS('http://www.w3.org/2000/svg','circle'); c.setAttribute('cx',cx); c.setAttribute('cy',cy); c.setAttribute('r',r); c.setAttribute('fill','none'); c.setAttribute('stroke','#fff'); c.setAttribute('stroke-width',sw); s.appendChild(c);}
function line(s,x1,y1,x2,y2,sw=2){const l=document.createElementNS('http://www.w3.org/2000/svg','line'); l.setAttribute('x1',x1); l.setAttribute('y1',y1); l.setAttribute('x2',x2); l.setAttribute('y2',y2); l.setAttribute('stroke','#eee'); l.setAttribute('stroke-width',sw); s.appendChild(l);}

function updateHUD(){
  const t = document.getElementById('turnLabel');
  if (t) t.textContent = (turn===1 ? 'Joueur' : `IA ${turn-1}`);
  const y = document.getElementById('yearLabel');
  if (y) y.textContent = YEAR;
}
function addLog(s,d=null,owner=null){ const e=document.createElement('div'); e.className='entry'; if(owner) e.dataset.owner=owner; e.innerHTML=`<div class="summary">• ${s}</div><div class="detail">${d?d:s}</div>`; e.querySelector('.summary').onclick=()=>e.classList.toggle('open'); logEl.insertAdjacentElement('afterbegin',e); }

function onCellClick(e){
  if (justPanned) return;
  const x=+e.currentTarget.dataset.x, y=+e.currentTarget.dataset.y, c=cell(x,y);
  if (shipBuildMode){
    const ok = shipBuildMode.spots.some(([sx,sy])=>sx===x && sy===y);
    if (ok){
      if ((gold[1]||0) < shipBuildMode.cost){
        addLog("Pas assez d'or", `Coût ${shipBuildMode.cost} or`, 1);
      } else {
        const t = cell(x,y);
        t.ship = { owner:1, kind: shipBuildMode.kind, cargo:[], moved:true, hp: SHIPS[shipBuildMode.kind].hp };
        gold[1] -= shipBuildMode.cost;
        addLog(`${SHIPS[shipBuildMode.kind].name} mis à l'eau`, `En ${x},${y}`, 1);
      }
    }
    shipBuildMode = null; spawnChoices = []; render();
    return;
  }
  if (spawnMode){
    const match = spawnMode.spots.some(([sx,sy])=>sx===x && sy===y);
    if (match){
      if ((gold[1]||0) < spawnMode.cost){
        addLog("Pas assez d'or", `Coût ${spawnMode.cost} or`, 1);
      } else if (spawnUnit(x,y,{owner:1,type:spawnMode.type,level:1},true)){
        gold[1] -= spawnMode.cost;
        addLog(`Recrutement: ${UNITS[spawnMode.type].name}`, `Posé en ${x},${y} (coût ${spawnMode.cost})`, 1);
      }else{
        addLog("Échec de pose", "La case n'est plus libre.", 1);
      }
    }
    spawnMode = null; spawnChoices = []; render();
    return;
  }
  if(selected && reach.some(([mx,my])=>mx===x&&my===y)){
    if(selected.kind==='unit') moveUnit(selected.x,selected.y,x,y,false);
    else if(selected.kind==='ship') moveShip(selected.x,selected.y,x,y);
    const here=cell(x,y);
    selected={x,y,kind:(here?.ship?'ship':(here?.unit?'unit':(here?.structure==='city'&&here?.owner===1?'city':'empty')))};
    render(); return;
  }
  if(turn!==1){ selected=null; render(); return; }
  if(c?.unit && c.unit.owner===1) selected={x,y,kind:'unit'};
  else if(c?.ship && c.ship.owner===1) selected={x,y,kind:'ship'};
  else if(c?.structure==='city' && c.owner===1) selected={x,y,kind:'city'};
  else if((c?.terrain==='land'||c?.terrain==='forest') && c.owner===1 && !c.unit && !c.ship && c.structure==='none') selected={x,y,kind:'empty'};
  else selected=null;
  render();
}

endBtn.onclick = () => {
  if (uiLocked) return;
  uiLocked = true;
  endBtn.disabled = true;
  endTurn();
};
document.getElementById('restart').onclick=()=>{ setSeed(CURRENT_SEED); const aiCount=+document.getElementById('aiCount').value||0; const allied=+document.getElementById('aiAllied').value; const diff=+document.getElementById('difficulty').value||2; genMap(CURRENT_SIZE,aiCount,allied,diff); uiLocked=false; endBtn.disabled=false; render(); centerBoard(); addLog(`Relance de la carte (seed ${CURRENT_SEED})`,null,1); };
document.getElementById('menu').onclick=()=>{ uiLocked=false; endBtn.disabled=false; showStart(); };

function applyBankruptcy(owner){
  const upk=upkeep(owner);
  if((gold[owner]||0)>=upk) return;
  for(const c of S){ if(c.unit&&c.unit.owner===owner)c.unit=null; if(c.ship&&c.ship.owner===owner)c.ship=null; }
  gold[owner]=Math.max(0,gold[owner]||0);
  addLog(`${owner===1?'Joueur':('IA '+(owner-1))} en banqueroute : armée dissoute`,`Loyer (${upk.toFixed(1)}) > or disponible.`,owner);
}

function endTurn(){
  const inc = income(turn);
  gold[turn] = (gold[turn] || 0) + inc;
  const upk = upkeep(turn);
  gold[turn] -= upk;
  addLog(`Tour ${turn===1?'Joueur':'IA '+(turn-1)} : +${inc} or, -${upk.toFixed(1)} or de loyer`, null, turn);

  // -> vérifier la banqueroute du joueur QUI VIENT DE JOUER
  applyBankruptcy(turn);

  recalcMoved(false); selected=null;
  turn++;
  if (turn > TOTAL_PLAYERS) {  turn = 1;  YEAR++; }

  // Régénération au début du tour du nouveau joueur (Joueur ou IA)
  healUnits(turn);

  render(); checkVictory();

  if (turn !== 1){
    setTimeout(()=>aiTurn(turn),250);
  } else {
    uiLocked=false;
    endBtn.disabled=false;
  }
}

// Mini-modal de fin (victoire / défaite)
function showEndModal(txt){
  const m = document.getElementById('endModal');
  const t = document.getElementById('end-title');
  t.textContent = txt;
  m.classList.add('show');
  document.getElementById('endClose')?.focus();
}
document.getElementById('endClose')?.addEventListener('click', () => {
  document.getElementById('endModal')?.classList.remove('show');
});
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape'){
    document.getElementById('endModal')?.classList.remove('show');
  }
});

function checkVictory(){
  const aiAlive=S.some(c=>(c.unit&&c.unit.owner>1)||(c.structure==='city'&&c.owner>1));
  const playerAlive=S.some(c=>(c.unit&&c.unit.owner===1)||(c.structure==='city'&&c.owner===1));
  if(!aiAlive) setTimeout(()=>showEndModal("Victoire !"),60);
  if(!playerAlive) setTimeout(()=>showEndModal("Défaite…"),60);
}

function nearestEnemyOrCity(x,y,owner){
  let best = null, bestD = 1e9;
  for (const c of S){
    const isTarget = (c.unit && isEnemy(owner, c.unit.owner)) || (c.structure === 'city' && isEnemy(owner, c.owner));
    if (!isTarget) continue;
    const d = hexDist({x,y}, c);
    if (d < bestD){ bestD = d; best = c; }
  }
  return best;
}

function nearestPlayerCoast(owner){
  let best = null, bestD = 1e9;
  for (const c of S){
    const isSea = (c.terrain === 'shallow' || c.terrain === 'deep');
    if (!isSea) continue;
    const touchesEnemyLand = neighbors(c.x,c.y).some(([nx,ny])=>{
      const t = cell(nx,ny);
      return t && isEnemy(owner, t.owner) && (t.terrain==='land' || t.terrain==='forest');
    });
    if (!touchesEnemyLand) continue;
    const d = Math.abs(c.x-(W>>1)) + Math.abs(c.y-(H>>1));
    if (d < bestD){ bestD = d; best = c; }
  }
  return best;
}

function aiTurn(owner){
  const RESERVE=[2,4,6,10][DIFFICULTY-1]||4;
  const vAI=S.filter(c=>c.structure==='city'&&c.owner===owner&&!c.unit&&!c.ship);
  for(const v of vAI){
    const tryRecruit=t=>{
      const cost=recruitCost(t,owner), upk=UNITS[t].upkeep, inc=income(owner), nextGold=(gold[owner]||0)-cost+inc-(upkeep(owner)+upk);
      if((gold[owner]||0)-cost>=RESERVE && nextGold>=0){
        const spots = spawnSpotsAroundCity(v.x,v.y,owner,t);
        if (spots.length){
          const [dx,dy] = spots[0];
          spawnUnit(dx,dy,{owner,type:t,level:1},true);
          gold[owner]-=cost;
          addLog(`IA ${owner-1} recrute un ${UNITS[t].name}`,null,owner);
          return true;
        }
      }
      return false;
    };
    if(tryRecruit(3)) continue; if(tryRecruit(2)) continue; tryRecruit(1);
  }
  const tilesAI=S.filter(c=>c.owner===owner&&(c.terrain==='land'||c.terrain==='forest')).length;
  const maxShips=Math.max(1,Math.floor(tilesAI/(DIFFICULTY>=3?6:8)));
  const curShips=S.filter(c=>c.ship&&c.ship.owner===owner).length;
  if(curShips<maxShips){
    const coastal=S.find(c=>c.unit&&c.unit.owner===owner&&neighbors(c.x,c.y).some(([nx,ny])=>{const t=cell(nx,ny);return !!t && t.terrain!=='land'&&!t.ship;}));
    if(coastal){
      const seaShallow=neighbors(coastal.x,coastal.y).find(([nx,ny])=>{const t=cell(nx,ny);return t?.terrain==='shallow'&&!t.ship;});
      const tryShip = seaShallow ? 'sloop' : 'brig';
      const shipDef = SHIPS[tryShip];
      const cost    = shipBuildCost(tryShip, owner);
      const upk     = shipDef.upkeep, inc = income(owner);

      const nextGold=(gold[owner]||0)-cost+inc-(upkeep(owner)+upk);
      if((gold[owner]||0)-cost>=RESERVE && nextGold>=0){
        const pos=seaShallow?seaShallow:neighbors(coastal.x,coastal.y).find(([nx,ny])=>{const t=cell(nx,ny);return !!t && (t.terrain==='deep'||t.terrain==='shallow')&&!t.ship;});
        if(pos){ const [sx,sy]=pos; gold[owner]-=cost; cell(sx,sy).ship={owner,kind:tryShip,cargo:[{...coastal.unit}],moved:true,hp:shipDef.hp}; coastal.unit=null; addLog(`IA ${owner-1} met un ${shipDef.name.toLowerCase()} à l'eau`,null,owner); }
      }
    }
  }
  const units=S.filter(c=>c.unit&&c.unit.owner===owner);
  for(const u of units){
    if(u.unit.moved) continue;
    const tgt=nearestEnemyOrCity(u.x,u.y,owner);
    const opts=reachableFrom(u.x,u.y,'unit',u.unit.type);
    if(opts.length && tgt){
      opts.sort((a,b)=>hexDist({x:a[0],y:a[1]},tgt)-hexDist({x:b[0],y:b[1]},tgt));
      const [nx,ny]=opts[0];
      moveUnitAI(u.x,u.y,nx,ny,owner,false);
    }
  }
  const boats=S.filter(c=>c.ship&&c.ship.owner===owner);
  for(const b of boats){
    if(b.ship.moved) continue;
    const shore=neighbors(b.x,b.y).find(([nx,ny])=>{
      const t=cell(nx,ny);
      return !!t && (t.terrain==='land'||t.terrain==='forest')&&!t.unit&&!(t.structure==='tower'&&isEnemy(owner,t.owner))&& (t.owner===0 || canAnnex(owner,nx,ny));
    });
    if(shore && b.ship.cargo&&b.ship.cargo.length){
      const [dx,dy]=shore; const t=cell(dx,dy); t.unit={...b.ship.cargo.shift(),moved:true}; t.owner=owner; b.ship.moved=true; addLog(`IA ${owner-1} débarque`,null,owner); continue;
    }
    const tgt=nearestPlayerCoast(owner); const opts=reachableFrom(b.x,b.y,'ship',b.ship.kind);
    if (tgt && opts.length){
      opts.sort((a,b2)=>hexDist({x:a[0],y:a[1]},tgt)-hexDist({x:b2[0],y:b2[1]},tgt));
      const [nx,ny] = opts[0]; moveShipAI(b.x, b.y, nx, ny, owner);
    }
  }

  render(); checkVictory(); endTurn();
}

function randomSeed(){ return (Math.random()*0xFFFFFFFF)>>>0; }

function hideStart(){ document.getElementById('start').classList.remove('show'); }
function showStart(){
  const m = document.getElementById('start');
  m.classList.add('show');
  // focus le premier bouton de taille
  const firstBtn = m.querySelector('.sizes [data-size]');
  firstBtn?.focus();
}

function startGame(sizeKey){
  CURRENT_SIZE = sizeKey;
  const aiCount = +document.getElementById('aiCount').value || 0;
  const allied  = +document.getElementById('aiAllied').value;
  const diff    = +document.getElementById('difficulty').value || 2;
  const sTxt    = document.getElementById('seedInput').value.trim();
  setSeed(sTxt || randomSeed());
  genMap(CURRENT_SIZE, aiCount, allied, diff);
  uiLocked=false; endBtn.disabled=false;
  hideStart();
  render(); centerBoard();
  document.documentElement.style.setProperty('--my', playerColor);
}

function initStartUI(){
  const sw = document.getElementById('swatches');
  sw.innerHTML = '';
  PLAYER_COLORS.forEach((c,i)=>{
    const b = document.createElement('button');
    b.className='swatch'; b.style.background=c.v; b.title=c.n;
    if (i===1) b.dataset.sel='1';
    b.onclick=()=>{
      playerColor=c.v;
      document.documentElement.style.setProperty('--my', playerColor);
      [...sw.children].forEach(el=>el.dataset.sel='0');
      b.dataset.sel='1';
    };
    sw.appendChild(b);
  });

  document.getElementById('diceSeed').onclick=()=>{
    const s = randomSeed();
    document.getElementById('seedInput').value = '0x'+s.toString(16);
    setSeed(s);
  }

  const btnCopy = document.getElementById('copySeed');
  if (btnCopy){
    btnCopy.onclick = () => {
      const input = document.getElementById('seedInput');
      const label = document.getElementById('seedLabel');
      const val = (input?.value.trim()) || (label?.textContent.trim());
      if (!val) return;
      navigator.clipboard?.writeText(val);
    };
  }

  };

  document.querySelectorAll('#start .sizes [data-size]').forEach(btn=>{
    btn.onclick = ()=> startGame(btn.dataset.size);
  });

  document.getElementById('zoomIn').onclick = ()=>{
    zoom = Math.min(MAX_ZOOM, +(zoom+ZOOM_STEP).toFixed(2)); applyView();
  };
  document.getElementById('zoomOut').onclick = ()=>{
    zoom = Math.max(MIN_ZOOM, +(zoom-ZOOM_STEP).toFixed(2)); applyView();
  };

  // --- Drag au doigt/souris avec Pointer Events ---
let moveThreshold = 4;   // px avant de considérer que c'est un drag
let moved = 0;

function onPtrDown(e){
  if (e.button !== undefined && e.button !== 0) return; // bouton principal only
  isDragging = true;
  justPanned = false;
  moved = 0;

  dragStartX = e.clientX;
  dragStartY = e.clientY;
  panStartX  = panX;
  panStartY  = panY;

  boardEl.setPointerCapture?.(e.pointerId);
  boardEl.classList.add('dragging');
}

function onPtrMove(e){
  if (!isDragging) return;
  const dx = e.clientX - dragStartX;
  const dy = e.clientY - dragStartY;
  moved = Math.max(moved, Math.abs(dx) + Math.abs(dy));
  if (moved > moveThreshold) justPanned = true;

  panX = panStartX + dx;
  panY = panStartY + dy;
  applyView();
}

function onPtrUp(e){
  if (!isDragging) return;
  isDragging = false;
  boardEl.releasePointerCapture?.(e.pointerId);
  boardEl.classList.remove('dragging');
  // petit délai pour bloquer le "click" fantôme après un drag
  setTimeout(()=>{ justPanned = false; }, 80);
}

// Enregistrements
if ('PointerEvent' in window){
  boardEl.addEventListener('pointerdown', onPtrDown);
  boardEl.addEventListener('pointermove', onPtrMove);
  boardEl.addEventListener('pointerup', onPtrUp);
  boardEl.addEventListener('pointercancel', onPtrUp);
} else {
  // Fallback très large (vieux navigateurs) : souris + touch
  boardEl.addEventListener('mousedown', (e)=>onPtrDown(e));
  window.addEventListener('mousemove', (e)=>onPtrMove(e));
  window.addEventListener('mouseup',   (e)=>onPtrUp(e));

  boardEl.addEventListener('touchstart', (e)=>{
    const t = e.touches[0]; if(!t) return;
    onPtrDown({clientX:t.clientX, clientY:t.clientY});
  }, {passive:true});
  boardEl.addEventListener('touchmove', (e)=>{
    const t = e.touches[0]; if(!t) return;
    onPtrMove({clientX:t.clientX, clientY:t.clientY});
  }, {passive:true});
  boardEl.addEventListener('touchend', (e)=>{
    onPtrUp({});
  });
}

initStartUI();
showStart();

// Bouton tiroir paysage mobile
const fab = document.getElementById('toggleSidebar');
fab.addEventListener('click', () => {
  const open = document.body.classList.toggle('show-sidebar');
  fab.setAttribute('aria-pressed', open ? 'true' : 'false');
});

// Fermer le tiroir avec la touche Échap
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && document.body.classList.contains('show-sidebar')){
    document.body.classList.remove('show-sidebar');
    document.getElementById('toggleSidebar')?.setAttribute('aria-pressed','false');
  }
});

// Ferme le tiroir si on clique dans le plateau
document.getElementById('board').addEventListener('click', () => {
  if (document.body.classList.contains('show-sidebar')) {
    document.body.classList.remove('show-sidebar');
  }
});

// --- Affichage de la version ---
const BUILD = 'v0.8.2';
const el = document.getElementById('buildLabel');
if (el) el.textContent = BUILD;

const headerEl = document.querySelector('header');
function syncHeadH(){
  const h = headerEl ? headerEl.offsetHeight : 72;
  document.documentElement.style.setProperty('--headH', h + 'px');
}
window.addEventListener('resize', syncHeadH);
window.addEventListener('orientationchange', syncHeadH);
window.addEventListener('DOMContentLoaded', syncHeadH);
syncHeadH();

})(); // fin de l'IIFE
</script>
  <div id="endModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="end-title">
    <div class="card">
      <h2 id="end-title"></h2>
      <button type="button" id="endClose">OK</button>
    </div>
  </div>
</body>
</html>