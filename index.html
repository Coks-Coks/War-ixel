<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>War-ixel</title>
<style>
  :root{
    --deep:#255c9e;
    --shallow:#8fd0ff;
    --ai:#b71c1c;
    --select:#ffcc00;
    --my:#1e3a8a;
    --reach-fill:rgba(60,170,120,.32);
    --theo-fill:rgba(100,140,220,.20);
    --bg:#eae4d6;
    --ink:#171717;
    --paper1:#f4e2b8; --paper2:#f0d59a; --paper3:#e8c77a; --paper-ink:#473924;
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}

  header{
    position:sticky; top:0; z-index:20;
    padding:10px 14px;
    display:flex;flex-wrap:wrap;gap:8px;align-items:center;justify-content:flex-start;
    color:var(--paper-ink);
    border-bottom:1px solid #c8b99c;
    background:linear-gradient(180deg,#fff7 0 10%, #0000 25% 75%, #fff6 90% 100%),
      radial-gradient(55% 120% at -5% -40%, #0002 0 40%, #0000 60%),
      radial-gradient(45% 110% at 110% -40%, #0002 0 40%, #0000 60%),
      linear-gradient(180deg,var(--paper1),var(--paper2) 55%,var(--paper3));
    box-shadow:inset 0 1px 0 #fff7,inset 0 -1px 0 #0001,0 4px 16px rgba(0,0,0,.12);
  }
  .paper-chip{padding:6px 10px;border-radius:9px;border:1px solid #d7c7ad;background:#fff9;backdrop-filter:blur(2px)}
  .controls{display:flex;gap:8px;align-items:center}
  .controls button{padding:8px 12px;border:1px solid #cdbb98;border-radius:9px;background:#fff9;cursor:pointer;box-shadow:inset 0 1px 0 #fff7}

  .layout{
    display:grid;
    grid-template-columns:320px 1fr;
    gap:12px;
    padding:12px;
    height: calc(100vh - 72px);
  }
  #sidebar,#board{min-height:0}
  #sidebar{display:flex;flex-direction:column;gap:12px;overflow:auto}

  .paper{
    border-radius:14px;border:1px solid #d7c7ad;color:var(--paper-ink);padding:12px 14px;
    background:linear-gradient(180deg,#fff9 0 10%, #0000 30% 70%, #fff6 90% 100%),
      repeating-linear-gradient( 6deg, #0000 0 12px, #0001 12px 13px),
      linear-gradient(180deg, var(--paper1), var(--paper2) 55%, var(--paper3));
    box-shadow:inset 0 1px 0 #fff7,inset 0 -1px 0 #0001,0 10px 24px rgba(0,0,0,.18);
  }
  .paper h3{margin:0 0 8px 0;color:#3b2f20}

  #actions{display:grid;gap:6px}
  #actions button{
    padding:10px 12px;border-radius:10px;border:1px solid #cdbb98;cursor:pointer;
    text-align:left;display:flex;flex-direction:column;align-items:flex-start;gap:2px;
    background:linear-gradient(180deg,#fff9 0 30%, #0000 60%),
      repeating-linear-gradient(6deg,#0000 0 12px,#0001 12px 13px),
      linear-gradient(180deg,#f7e8bf,#f2d793 55%,#e6c377);
    box-shadow:inset 0 1px 0 #fff7, 0 2px 8px rgba(0,0,0,.08);
  }
  #actions button .title{font-weight:700;color:#3b2f20}
  #actions button .meta{font-size:12px;opacity:.8;color:#473924}
  #actions button[disabled]{display:none;}
  #actions .hint-msg{
    padding:10px 12px;border-radius:10px;border:1px dashed #cdbb98;
    background:#fff7;color:#473924;
  }

  #log{max-height:240px;overflow:auto}
  .entry{border-bottom:1px dashed #d7c7ad;padding:6px 0}
  .entry:last-child{border-bottom:0}
  .summary{cursor:pointer;font-weight:700}
  .detail{max-height:0;overflow:hidden;transition:max-height .25s ease;font-size:12px;color:#3f3527}
  .entry.open .detail{max-height:260px}
  .entry[data-owner="1"] .summary{color:var(--my)}
  .entry[data-owner="2"] .summary{color:var(--ai)}

  #board{
    position:relative;border:1px solid #c8bfae;border-radius:12px;padding:18px;
    display:flex;align-items:center;justify-content:center;
    background:repeating-linear-gradient(45deg, #cfe7ff 0 18px, #d8edff 18px 36px),
      radial-gradient(80% 60% at 0% 10%, #0000000b 0 50%, #0000 70%),
      radial-gradient(70% 70% at 100% 90%, #0000000d 0 50%, #0000 75%),
      linear-gradient(180deg, #fff, #fdfbf7 55%, #faf6ef);
    overflow:hidden; cursor:grab;
  }
  #board.dragging{cursor:grabbing}

  #stage{position:relative;margin:auto}
  #terrain, #overlay, #grid{position:absolute;left:0;top:0}
  #overlay{pointer-events:none;z-index:2}
  #grid{z-index:3}
  #world{position:absolute;left:0;top:0;will-change:transform}

  .hex{position:absolute;left:0;top:0;transform:translate(-50%,-50%);cursor:pointer}
  .hex.selected{
    outline:3px solid var(--select);outline-offset:-2px;
    box-shadow:0 0 0 3px rgba(255,204,0,.45), 0 0 26px rgba(255,204,0,.55) inset;
  }
  @keyframes selping{
    0%{transform:translate(-50%,-50%) scale(.7); opacity:.9;}
    70%{transform:translate(-50%,-50%) scale(1.25); opacity:0;}
    100%{opacity:0;}
  }
  .hex.selected::after{
    content:"";position:absolute; left:50%; top:50%;
    width:56px; height:56px; transform:translate(-50%,-50%);
    border-radius:50%; border:2px solid var(--select);
    opacity:.85; animation:selping 1.1s ease-out infinite;
  }

  .city, .tower{z-index: 1;}
  .badge{z-index: 2;}

  .badge{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    width:34px;height:34px;border-radius:50%;
    display:flex;align-items:center;justify-content:center;
    border:2px solid rgba(255,255,255,.85);box-shadow:0 1px 1px rgba(0,0,0,.08)
  }
  .badge .icon{width:18px;height:18px;display:block}
  .badge::after{content:none !important}
  .camo{opacity:.82}
  .camo::before{content:"";position:absolute;inset:-2px;background:repeating-linear-gradient(135deg,transparent 0 6px,rgba(0,0,0,.06) 6px 12px);mix-blend-mode:multiply;border-radius:8px}

  .tower,.city{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:32px;height:28px;border-radius:6px;border:2px solid rgba(0,0,0,.15)}
  .city{background:#c68c53;display:grid;place-items:center}
  .tower{background:#e0e0e0;display:grid;place-items:center}
  .tower svg{width:22px;height:22px}
  .castle{width:22px;height:16px}
  .ship{
    width:42px;height:26px;border-radius:6px;color:#fff;border:2px solid rgba(255,255,255,.85);
    display:flex;align-items:center;justify-content:center;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    box-shadow:0 1px 1px rgba(0,0,0,.08)
  }
  .hint{position:absolute;right:3px;top:2px;font-size:11px;background:rgba(0,0,0,.7);color:#fff;padding:1px 5px;border-radius:999px;z-index:4}

  #summary{display:grid;gap:8px}
  .sum-title{font-weight:700;margin-bottom:4px}
  .sum-list{margin:0;padding-left:0;list-style:none;display:grid;gap:3px}
  .sum-item{display:flex;align-items:center;justify-content:space-between;gap:6px;font-variant-numeric:tabular-nums;width:100%}
  .sum-ico{width:16px;height:16px;display:inline-block;vertical-align:middle}

  #overlay polygon{stroke-linejoin:round; vector-effect:non-scaling-stroke; shape-rendering:geometricPrecision;}

  .modal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:1000}
  .modal.show{display:flex}
  .card{background:#fff;border-radius:12px;border:1px solid #ddd;padding:16px;max-width:620px;width:92%;box-shadow:0 12px 30px rgba(0,0,0,.25)}
  .sizes{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:8px}
  .swatches{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  .swatch{width:28px;height:28px;border-radius:6px;border:2px solid #ddd;cursor:pointer;box-shadow:inset 0 0 0 2px rgba(255,255,255,.35)}
  .swatch[data-sel="1"]{outline:3px solid #0003}

  .hex.frontier{ box-shadow: inset 0 0 0 2px rgba(0,0,0,.12); }
  .hex.frontier.owned1{ box-shadow: inset 0 0 0 2px rgba(30,58,138,.35); }
  .hex.frontier.owned2{ box-shadow: inset 0 0 0 2px rgba(183,28,28,.35); }

</style>
</head>
<body>
<header>
  <div class="paper-chip">Tour: <b id="turnLabel">Joueur</b></div>
  <div class="paper-chip">Année: <b id="yearLabel">1</b></div>
  <div class="controls">
    <button id="endTurn">Finir le tour</button>
    <button id="restart">Recommencer</button>
    <button id="menu">Menu</button>
    <span class="paper-chip">Seed: <b id="seedLabel">—</b></span>
  </div>
</header>

<div class="layout">
  <div id="sidebar">
    <div class="paper">
      <h3>Actions</h3>
      <div id="actions">
        <button id="buildCity" disabled>Construire Ville</button>
        <button id="buildTower" disabled>Bâtir Tour (3 or)</button>
        <button id="recFarmer"  disabled>Recruter Fermier</button>
        <button id="recMilitia" disabled>Recruter Milicien</button>
        <button id="recSoldier" disabled>Recruter Soldat</button>
        <button id="upFarmMil"  disabled>Améliorer Fermier → Milice</button>
        <button id="upMilSold"  disabled>Améliorer Milice → Soldat</button>
        <button id="makeSloop" disabled>Sloop 1 mât (5 or)</button>
        <button id="makeBrig" disabled>Brigantin 2 mâts (10 or)</button>
        <button id="makeGalleon" disabled>Galion 3 mâts (20 or)</button>
        <button id="loadShip" disabled>Embarquer</button>
        <button id="disembark" disabled>Débarquer</button>
      </div>
    </div>
    <div class="paper">
      <h3>Gestion</h3>
      <div id="summary" style="font-size:13px;line-height:1.2"></div>
    </div>
    <div class="paper">
      <h3>Journal</h3>
      <div id="log"></div>
    </div>
  </div>

  <div id="board">
    <div id="viewControls" class="paper-chip" style="position:absolute;left:12px;top:12px;z-index:5;display:flex;gap:8px;align-items:center;">
      <button id="zoomOut" title="Zoom -">−</button>
      <span id="zoomLabel">100%</span>
      <button id="zoomIn"  title="Zoom +">+</button>
    </div>
    <div id="stage">
      <div id="world">
        <svg id="terrain"></svg>
        <svg id="overlay"></svg>
        <div id="grid"></div>
      </div>
    </div>
  </div>
</div>

<div id="start" class="modal show">
  <div class="card">
    <h2>War-ixel — Nouvelle partie</h2>
    <p>Choisis <b>ta couleur</b>, la <b>taille</b>, le <b>nombre d'IA</b>, leurs <b>alliances</b> et la <b>difficulté</b> (1 novice → 4 chef de guerre), puis (optionnel) une <b>seed</b> :</p>
    <div class="swatches" id="swatches"></div>
    <div style="margin-top:10px; display:grid; gap:8px; grid-template-columns:repeat(2,1fr);">
      <label>IA (0–4)<br><input id="aiCount" type="number" min="0" max="4" value="1" style="width:100%"></label>
      <label>IA alliées entre elles ?<br><select id="aiAllied" style="width:100%"><option value="1" selected>Oui</option><option value="0">Non</option></select></label>
      <label>Difficulté<br>
        <select id="difficulty" style="width:100%">
          <option value="1">1 — Novice</option>
          <option value="2" selected>2 — Normal</option>
          <option value="3">3 — Stratège</option>
          <option value="4">4 — Chef de guerre</option>
        </select>
      </label>
      <div></div>
    </div>
    <div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
      <label style="min-width:42px;">Seed</label>
      <input id="seedInput" type="text" placeholder="aléatoire" style="flex:1; padding:6px 8px; border:1px solid #ccc; border-radius:8px;">
      <button id="diceSeed" title="Seed aléatoire">🎲</button>
    </div>
    <div class="sizes" style="margin-top:8px">
      <button data-size="small">Petit</button>
      <button data-size="medium">Moyen</button>
      <button data-size="large">Grand</button>
      <button data-size="huge">Immense</button>
    </div>
  </div>
</div>

<script>
(function(){

const R = 34, HEX_W = 2*R, HEX_H = Math.sqrt(3)*R, STEP_X = 1.5*R, STEP_Y = HEX_H;
function hexCenter(x,y){ return { cx: x*STEP_X+R, cy: y*STEP_Y + ((x&1)?HEX_H/2:0) + HEX_H/2 }; }
function svgHexPoints(cx,cy,shrink=1){ const r=R*shrink, h=Math.sqrt(3)*r;
  const pts=[[cx-r/2,cy-h/2],[cx+r/2,cy-h/2],[cx+r,cy],[cx+r/2,cy+h/2],[cx-r/2,cy+h/2],[cx-r,cy]];
  return pts.map(p=>p.join(',')).join(' ');
}

const UNITS={1:{key:1,name:'Fermier',cost:1,upkeep:0.5,move:3},2:{key:2,name:'Milicien',cost:2,upkeep:1,move:2},3:{key:3,name:'Soldat',cost:3,upkeep:1.5,move:1}};
const SHIPS={sloop:{key:'sloop',name:'Sloop',cost:5,upkeep:2.5,move:3,water:'shallow',cap:1,hp:2,atk:1,masts:1},
             brig:{key:'brig',name:'Brigantin',cost:10,upkeep:5,move:2,water:'both',cap:2,hp:3,atk:1.5,masts:2},
             galleon:{key:'galleon',name:'Galion',cost:20,upkeep:10,move:1,water:'both',cap:3,hp:4,atk:2,masts:3}};
             
const DEF_BONUS_CITY = 0.5;         // bonus défense si l'unité défend dans SA ville
const GARRISON_UPKEEP_MULT = 0.5;   // entretien x0.5 pour une unité posée sur SA ville

const SUPPLY_PER_CITY = 3;          // capacité gratuite par ville
const SUPPLY_PER_LAND = 0.12;       // +cap par tuile terrestre possédée
const SHIP_SUPPLY = { sloop:1, brig:2, galleon:3 }; // poids supply des navires
const SUPPLY_OVER_COST = 1.0;       // coût d'entretien par point au-dessus du cap

const CAMO_RANGE = 5;
const CITY_BASE_COST=10, CITY_SCALE=3;
const SIZE_PRESETS={small:{W:13,H:11},medium:{W:19,H:15},large:{W:25,H:19},huge:{W:33,H:25}};

let W=13,H=11,S=[],selected=null,reach=[],reachTheo=[],turn=1,TOTAL_PLAYERS=2,AI_ALLIED=true,DIFFICULTY=2;
let YEAR=1;
let uiLocked=false, turnCount=1;
const gold={};
const PLAYER_COLORS=[{n:"Émeraude",v:"#1f7a3e"},{n:"Bleu roi",v:"#1e3a8a"},{n:"Violet",v:"#6a1b9a"},{n:"Ambre",v:"#e39a1d"},{n:"Carmin",v:"#c62828"},{n:"Teal",v:"#00897b"}];
let playerColor=PLAYER_COLORS[1].v;
const AI_PALETTE=["#b71c1c","#6a1b9a","#e39a1d","#00897b"];
function ownerColor(o){ if(o===1) return playerColor; return AI_PALETTE[(o-2)%AI_PALETTE.length]; }

let zoom=1, panX=0, panY=0;
const MIN_ZOOM=0.6, MAX_ZOOM=2.0, ZOOM_STEP=0.1;
let isDragging=false, dragStartX=0, dragStartY=0, panStartX=0, panStartY=0, justPanned=false;
let WpxCached=0, HpxCached=0;

const boardEl=document.getElementById('board'), stageEl=document.getElementById('stage'),
      worldEl=document.getElementById('world'), terrain=document.getElementById('terrain'),
      overlay=document.getElementById('overlay'), gridEl=document.getElementById('grid'), 
      logEl=document.getElementById('log'), endBtn=document.getElementById('endTurn');

let CURRENT_SIZE='small', CURRENT_SEED=0;
function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296;};}
let rand=Math.random;
function hashStringToInt(s){ if(s==null) return 0; if(/^0x/i.test(s)) return parseInt(s,16)>>>0; if(/^\d+$/.test(s)) return (parseInt(s,10)>>>0);
  return Array.from(String(s)).reduce((h,ch)=>(Math.imul(31,h)+ch.charCodeAt(0))>>>0,0);}
function setSeed(s){ const n=(typeof s==='string')?hashStringToInt(s):(s>>>0); CURRENT_SEED=(n||1)>>>0; rand=mulberry32(CURRENT_SEED); document.getElementById('seedLabel').textContent=CURRENT_SEED; }

function hexToRgb(h){h=h.replace('#','');if(h.length===3)h=[...h].map(x=>x+x).join('');const num=parseInt(h,16);return{r:(num>>16)&255,g:(num>>8)&255,b:num&255};}
function rgbToHex(r,g,b){const t=n=>n.toString(16).padStart(2,'0');return '#'+t(r)+t(g)+t(b);}
function mix(c1,c2,p){const a=hexToRgb(c1),b=hexToRgb(c2);return rgbToHex(Math.round(a.r+(b.r-a.r)*p),Math.round(a.g+(b.g-a.g)*p),Math.round(a.b+(b.b-a.b)*p));}
function regionColor(owner){ if(owner===0) return '#dbdbdb'; const base=ownerColor(owner); return mix(base,'#ffffff',0.60); }

function hash(i,j){const s=Math.sin(i*127.1+j*311.7+(CURRENT_SEED||0))*43758.5453;return s-Math.floor(s);}
function lerp(a,b,t){return a+(b-a)*t;} function fade(t){return t*t*(3-2*t);}
function noise2(x,y){const i=Math.floor(x),j=Math.floor(y);const u=fade(x-i),v=fade(y-j);const a=hash(i,j),b=hash(i+1,j),c=hash(i,j+1),d=hash(i+1,j+1);return lerp(lerp(a,b,u),lerp(c,d,u),v);}
function fbm(x,y,oct=4){let v=0,amp=0.5,freq=1;for(let o=0;o<oct;o++){v+=noise2(x*freq,y*freq)*amp;freq*=2;amp*=0.5;}return v;}

function inb(x,y){return x>=0&&y>=0&&x<W&&y<H;}
function idx(x,y){return y*W+x;}
function cell(x,y){ if(!inb(x,y)) return undefined; return S[idx(x,y)]; }
function neighbors(x,y){
  const out=[]; const odd=x&1;
  const E=[[-1,0],[+1,0],[0,-1],[0,+1],[-1,-1],[-1,+1]];
  const O=[[-1,0],[+1,0],[0,-1],[0,+1],[+1,-1],[+1,+1]];
  const dirs=odd?O:E;
  for(const[dx,dy] of dirs){ const nx=x+dx, ny=y+dy; if(inb(nx,ny)) out.push([nx,ny]); }
  return out;
}
function toCube(q,r){const x=q;const z=r-((q&1)?(q+1)/2:q/2);const y=-x-z;return{x,y,z};}
function hexDist(a,b){const ac=toCube(a.x,a.y),bc=toCube(b.x,b.y);return Math.max(Math.abs(ac.x-bc.x),Math.abs(ac.y-bc.y),Math.abs(ac.z-bc.z));}

function genMap(sizeKey, aiCount=1, allied=true, difficulty=2){
  AI_ALLIED=!!+allied; DIFFICULTY=+difficulty||2; TOTAL_PLAYERS=1+(+aiCount||0);
  const p=SIZE_PRESETS[sizeKey]||SIZE_PRESETS.small; W=p.W; H=p.H; S.length=0;
  for(let y=0;y<H;y++)for(let x=0;x<W;x++)S.push({x,y,terrain:'land',owner:0,structure:'none',unit:null,ship:null,e:0,shore:false});

  for(const c of S){
    const sx=c.x/W*6, sy=c.y/H*6; const elev=fbm(sx,sy,5), humid=fbm(sx+20,sy-13,4); c.e=elev;
    const edge=Math.min(c.x,W-1-c.x,c.y,H-1-c.y)/Math.min(W,H);
    const coastBias=(edge<0.08)?-0.2:0; const seaLevel=0.50+coastBias;
    if(elev<seaLevel-0.12) c.terrain='deep';
    else if(elev<seaLevel) c.terrain='shallow';
    else c.terrain=(humid>0.53?'forest':'land');
  }
  for(const c of S) if(c.terrain==='deep'&&neighbors(c.x,c.y).some(([nx,ny])=>['land','forest'].includes(cell(nx,ny)?.terrain))) c.terrain='shallow';
  for(const c of S) c.shore=((c.terrain==='land'||c.terrain==='forest') && neighbors(c.x,c.y).some(([nx,ny])=> ['shallow','deep'].includes(cell(nx,ny)?.terrain)));

  const starts=[]; starts.push(findNearestLandOnly(1,1));
  for(let k=0;k<aiCount;k++){const p2=randomFarLandOnly(starts,Math.floor(Math.min(W,H)/2.2))||randomFarLandOnly(starts,6)||findNearestLandOnly(W-2,H-2); starts.push(p2);}

  for(let i=0;i<starts.length;i++){
    const o=i+1, p3=starts[i];
    const city = cell(p3.x,p3.y);
    city.structure='city'; city.owner=o;

    const cand = neighbors(p3.x,p3.y).find(([nx,ny])=>{
      const t=cell(nx,ny);
      if(!t) return false;
      if(t.structure!=='none'||t.unit||t.ship) return false;
      if(!(t.terrain==='land'||t.terrain==='forest')) return false;
      if(!passableForUnit(city,t,o,1)) return false;
      return (t.owner===o) || (t.owner===0 && canAnnex(o,nx,ny));
    });
    if (cand){
      const [ux,uy]=cand; const t=cell(ux,uy);
      t.unit={owner:o,type:1,level:1,moved:true};
      t.owner=o;
    }
    gold[o]=2;
  }
  turn=1; turnCount=1; recalcMoved(false); YEAR=1;
}

function findNearestLandOnly(sx,sy){let best={x:sx,y:sy},bestD=1e9;for(const c of S){if(c.terrain==='land'){const d=Math.abs(c.x-sx)+Math.abs(c.y-sy);if(d<bestD){bestD=d;best={x:c.x,y:c.y};}}}return best;}
function randomFarLandOnly(points,minD){const candidates=S.filter(c=>(c.terrain==='land')&&c.structure==='none');for(let t=0;t<800;t++){const c=candidates[Math.floor(rand()*candidates.length)];if(!c)break;if(points.every(p=>hexDist(c,p)>=minD))return{x:c.x,y:c.y};}return null;}
function recalcMoved(flag){for(const c of S){if(c.unit)c.unit.moved=flag;if(c.ship)c.ship.moved=flag;}}

function income(o){let inc=0;for(const c of S){if(c.owner===o&&(c.terrain==='land'||c.terrain==='forest'))inc++; if(c.owner===o&&c.structure==='city')inc+=2;} return inc;}
// --- NEW: décomposition exacte de l'entretien pour l'UI ---
function upkeepBreakdown(owner){
  const byUnit = {1:0, 2:0, 3:0};
  const byShip = {sloop:0, brig:0, galleon:0};
  let landOwned = 0, cities = 0, supplyUsed = 0;

  for (const c of S){
    if (c.owner === owner && (c.terrain==='land' || c.terrain==='forest')) landOwned++;
    if (c.owner === owner && c.structure === 'city') cities++;

    if (c.unit && c.unit.owner === owner){
      const lvl = (c.unit.level || 1);
      let uCost = UNITS[c.unit.type].upkeep * lvl;
      if (c.structure === 'city' && c.owner === owner) uCost *= GARRISON_UPKEEP_MULT; // -50% en garnison
      byUnit[c.unit.type] += uCost;
      supplyUsed += lvl;
    }

    if (c.ship && c.ship.owner === owner){
      byShip[c.ship.kind] += SHIPS[c.ship.kind].upkeep;
      supplyUsed += (SHIP_SUPPLY[c.ship.kind] || 1);
    }
  }

  const cap = Math.floor(cities * SUPPLY_PER_CITY + landOwned * SUPPLY_PER_LAND);
  const over = Math.max(0, supplyUsed - cap);
  const overCost = over * SUPPLY_OVER_COST;

  const total = +(byUnit[1] + byUnit[2] + byUnit[3] + byShip.sloop + byShip.brig + byShip.galleon + overCost).toFixed(1);
  return { byUnit, byShip, cap, supplyUsed, over, overCost, total };
}

// Garde cette signature pour le reste du code (IA, etc.)
function upkeep(o){ return upkeepBreakdown(o).total; }

function cityCost(o){const owned=S.filter(c=>c.structure==='city'&&c.owner===o).length-1;return CITY_BASE_COST + CITY_SCALE*Math.max(0,owned);}
function countSummary(o){const units={1:0,2:0,3:0}, ships={sloop:0,brig:0,galleon:0}; for(const c of S){if(c.unit&&c.unit.owner===o)units[c.unit.type]+=(c.unit.level||1); if(c.ship&&c.ship.owner===o)ships[c.ship.kind]++;} return{units,ships};}

function renderSummary(){
  const box = document.getElementById('summary');
  if (!box) return;

  const counts = countSummary(1);
  const gMe    = Math.floor(gold[1] || 0);
  const bd     = upkeepBreakdown(1);
  const fmt    = (n)=> Number(n).toFixed(1);
  const net    = Number((gMe - bd.total).toFixed(1));

  // Ennemis (affichage conditionnel selon TOTAL_PLAYERS)
  const enemies = [];
  for (let o=2; o<=TOTAL_PLAYERS; o++) enemies.push({ id:o-1, g: Math.floor(gold[o] || 0) });

  box.innerHTML = `
    <ul class="sum-list">
      <li class="sum-item"><span>Fortune actuelle</span><b>${gMe}</b></li>
      <li class="sum-item"><span>Frais d'entretien</span><b>${fmt(bd.total)}</b></li>
      <li class="sum-item"><span>Surcharge logistique</span><b>${fmt(bd.overCost)}</b></li>
      <li class="sum-item"><span>Solde pour l'année suivante</span><b>${fmt(net)}</b></li>
    </ul>

    <div class="sum-title">Armée</div>
    <ul class="sum-list">
      <li class="sum-item"><span>Fermier</span><b>${counts.units[1]} <span style="opacity:.8">(-${fmt(bd.byUnit[1])} pièce d'or)</span></b></li>
      <li class="sum-item"><span>Milice</span><b>${counts.units[2]} <span style="opacity:.8">(-${fmt(bd.byUnit[2])} pièce d'or)</span></b></li>
      <li class="sum-item"><span>Soldat</span><b>${counts.units[3]} <span style="opacity:.8">(-${fmt(bd.byUnit[3])} pièce d'or)</span></b></li>
    </ul>

    <div class="sum-title">Flotte</div>
    <ul class="sum-list">
      <li class="sum-item"><span>Sloop</span><b>${counts.ships.sloop} <span style="opacity:.8">(-${fmt(bd.byShip.sloop)} pièce d'or)</span></b></li>
      <li class="sum-item"><span>Brigantin</span><b>${counts.ships.brig} <span style="opacity:.8">(-${fmt(bd.byShip.brig)} pièce d'or)</span></b></li>
      <li class="sum-item"><span>Galion</span><b>${counts.ships.galleon} <span style="opacity:.8">(-${fmt(bd.byShip.galleon)} pièce d'or)</span></b></li>
    </ul>

    <div class="sum-title">Ennemi</div>
    <ul class="sum-list">
      <li class="sum-item"><span>Nombre d'ennemi</span><b>${enemies.length}</b></li>
      ${enemies.map(e => `
        <li class="sum-item"><span>Or présumé IA ${e.id}</span><b>${e.g}</b></li>
      `).join('')}
    </ul>
  `;
}

function isEnemy(a,b){ if(a===b) return false; if(AI_ALLIED&&a>1&&b>1) return false; return true; }
function beats(att,def){ if(att===def) return 0; return (att>def)?1:-1; }

function moveCostUnit(type, from, to, owner){
  if (!to) return Infinity;
  // On interdit seulement la tour ennemie ; la ville est autorisée
  if (to.structure === 'tower' && isEnemy(owner, to.owner)) return Infinity;
  if (to.terrain === 'shallow' || to.terrain === 'deep') return Infinity;
  if (to.terrain === 'forest'){
    if (type === 1 || type === 2) return 2;
    return Infinity;
  }
  return 1;
}

function passableForUnit(from, to, owner, type){
  if (!to) return false;
  if (to.structure === 'tower' && isEnemy(owner, to.owner)) return false; // ville OK
  if (to.terrain === 'shallow' || to.terrain === 'deep') return false;
  if (to.terrain === 'forest' && !(type === 1 || type === 2)) return false;
  if (to.unit && !isEnemy(owner, to.unit.owner) && to.unit.type !== type) return false;
  return true;
}

function passableForShip(from,to,owner,kind){
  if(!to) return false;
  if(to.ship) return false;
  if(to.structure==='tower'&&isEnemy(owner,to.owner)) return false;
  const rule=SHIPS[kind].water;
  if(rule==='shallow'&&to.terrain!=='shallow') return false;
  if(rule==='both'&&!(to.terrain==='shallow'||to.terrain==='deep')) return false;
  return true;
}

function reachableFrom(x, y, kind, param){
  const start = cell(x, y);
  const out = [];

  if (kind === 'ship'){
    const maxStep = SHIPS[start.ship.kind].move;
    const seen = new Map();
    const q = [[x, y, 0]];
    seen.set(idx(x,y), 0);
    while (q.length){
      const [cx, cy, st] = q.shift();
      const here = cell(cx, cy);
      for (const [nx, ny] of neighbors(cx, cy)){
        const there = cell(nx, ny);
        if (st + 1 > maxStep) continue;
        if (!passableForShip(here, there, start.ship.owner, start.ship.kind)) continue;
        const k = idx(nx, ny);
        if (seen.has(k) && seen.get(k) <= st + 1) continue;
        seen.set(k, st + 1);
        out.push([nx, ny]);
        q.push([nx, ny, st + 1]);
      }
    }
    return out;
  }

  const type   = start.unit.type;
  const owner  = start.unit.owner;
  const budget = UNITS[type].move;
  const dist = new Map();
  const open = [];
  const popMin = (arr) => { let k=0; for(let i=1;i<arr.length;i++) if(arr[i][2]<arr[k][2]) k=i; return arr.splice(k,1)[0]; };
  dist.set(idx(x,y), 0);
  open.push([x, y, 0]);

  while (open.length){
    const [cx, cy, costHere] = popMin(open);
    const here = cell(cx, cy);
    for (const [nx, ny] of neighbors(cx, cy)){
      const there = cell(nx, ny);
      if (!there) continue;
      if (!passableForUnit(here, there, owner, type)) continue;
      if (there.owner !== owner){
        if (there.owner === 0){
          if (!canAnnex(owner, nx, ny)) continue;
        } else if (isEnemy(owner, there.owner)){
          if (!canAnnex(owner, nx, ny)) continue;
        }
      }
      const step = moveCostUnit(type, here, there, owner);
      if (step === Infinity) continue;
      const newCost = costHere + step;
      if (newCost > budget) continue;
      const k = idx(nx, ny);
      if (dist.has(k) && dist.get(k) <= newCost) continue;
      dist.set(k, newCost);
      out.push([nx, ny]);
      const stopHere = (there.unit && isEnemy(owner, there.unit.owner)) || (there.owner > 0 && isEnemy(owner, there.owner));
      if (!stopHere){
        open.push([nx, ny, newCost]);
      }
    }
  }
  return out;
}

function canAnnex(owner,x,y){ return neighbors(x,y).some(([nx,ny])=>cell(nx,ny)?.owner===owner); }

function enemyHiddenForPlayer(t){
  if(!t) return false;
  const hasEnemy=(t.unit&&isEnemy(1,t.unit.owner))||(t.structure!=='none'&&isEnemy(1,t.owner));
  if(!hasEnemy) return false;
  if(t.terrain!=='forest') return false;
  for(const c of S){ if(c.unit&&c.unit.owner===1){ if(hexDist(c,t)<=CAMO_RANGE) return false; } }
  return true;
}

function ownedUnitsOfType(owner,type){let n=0; for(const c of S) if(c.unit&&c.unit.owner===owner&&c.unit.type===type) n+=(c.unit.level||1); return n;}
function totalUnitLevels(owner){
  let n = 0;
  for (const c of S) if (c.unit && c.unit.owner === owner) n += (c.unit.level || 1);
  return n;
}
function recruitCost(type, owner){
  const base = UNITS[type].cost;
  const sameType = ownedUnitsOfType(owner, type); // en "niveaux"
  const all = totalUnitLevels(owner);
  // +1 tous les 2 niveaux du même type, +1 tous les 6 niveaux au total
  return base + Math.floor(sameType / 2) + Math.floor(all / 6);
}

function upgradeCost(fromType, toType){
  if (fromType===1 && toType===2) return 2;
  if (fromType===2 && toType===3) return 3;
  return 99;
}

function ownedShips(owner){ let n=0; for(const c of S) if(c.ship && c.ship.owner===owner) n++; return n; }
function ownedShipsOfKind(owner, kind){ let n=0; for(const c of S) if(c.ship && c.ship.owner===owner && c.ship.kind===kind) n++; return n; }
function shipBuildCost(kind, owner){
  const base = SHIPS[kind].cost;
  return base + 2*ownedShipsOfKind(owner, kind) + Math.floor(ownedShips(owner)/2);
}

let spawnMode = null;
let spawnChoices = [];

function citySpawnCandidates(x,y,type,owner=1){
  return neighbors(x,y).filter(([nx,ny])=>{
    const t = cell(nx,ny);
    if (!t) return false;
    if (t.structure !== 'none') return false;
    if (t.unit || t.ship) return false;
    if (!(t.terrain==='land' || t.terrain==='forest')) return false;
    if (!passableForUnit({x,y}, t, owner, type)) return false;
    if (t.owner === owner) return true;
    if (t.owner === 0) return canAnnex(owner, nx, ny);
    return false;
  });
}

function beginSpawnFromCity(x,y,type){
  const cost = recruitCost(type,1);
  if ((gold[1]||0) < cost){ addLog("Pas assez d'or", `Coût ${cost} or`, 1); return; }
  const spots = citySpawnCandidates(x,y,type,1);
  if (spots.length === 0){
    addLog("Pas d'emplacement de camp à proximité.","Aucune case terrestre libre/annexable autour de la ville pour former une nouvelle armée.", 1);
    return;
  }
  if (spots.length === 1){
    const [dx,dy] = spots[0];
    gold[1] -= cost;
    if (spawnUnit(dx,dy,{owner:1,type,level:1},true)){
      addLog(`Recrutement: ${UNITS[type].name}`, `En ${dx},${dy} (coût ${cost})`, 1);
      render();
    }
    return;
  }
  spawnMode = { type, cost, spots };
  spawnChoices = spots.slice();
  addLog("Choisis une case de déploiement", "Clique sur une des cases surlignées autour de la ville.", 1);
  drawOverlay();
}

function spawnUnit(x,y,u,moved=true){
  const c = cell(x,y);
  if (!c || c.ship) return false;
  const placeHere = (t)=>{ 
    if (t.unit || t.ship) return false;
    t.unit = { owner:u.owner, type:u.type, level:u.level||1, moved };
    t.owner = u.owner;
    return true;
  };
  if (c.structure !== 'none'){
    const cand = neighbors(x,y).find(([nx,ny])=>{
      const t = cell(nx,ny);
      if (!t) return false;
      if (t.structure !== 'none') return false;
      if (!(t.terrain==='land' || t.terrain==='forest')) return false;
      if (t.unit || t.ship) return false;
      return (t.owner === u.owner) || canAnnex(u.owner, nx, ny);
    });
    if (!cand) return false;
    const [nx,ny] = cand;
    return placeHere(cell(nx,ny));
  }
  if (!(c.terrain==='land' || c.terrain==='forest')) return false;
  if (c.unit) return false;
  return placeHere(c);
}

function unitName(t){ return (UNITS[t]?.name||'Unité').toLowerCase(); }

function moveUnit(sx, sy, dx, dy, _viaReach=false){
  const src = cell(sx, sy), dst = cell(dx, dy);
  if (!src?.unit || src.unit.moved || src.unit.owner !== 1) return;
  if (dst?.structure !== 'none' && dst?.structure !== 'city') return;
  if (moveCostUnit(src.unit.type, src, dst, 1) === Infinity) return;

  // Fusion alliée (même type)
  if (dst?.unit && !isEnemy(1, dst.unit.owner) && dst.unit.type === src.unit.type){
    dst.unit.level = (dst.unit.level||1) + (src.unit.level||1);
    dst.unit.moved = true;
    src.unit = null;
    dst.owner = 1;
    addLog(`Fusion en ${dx},${dy}`, `Pile de ${UNITS[dst.unit.type].name} ×${dst.unit.level}`, 1);
    return;
  }

  // Combat contre ennemi sur la case
  if (dst?.unit && isEnemy(1, dst.unit.owner)){
    if (!canAnnex(1, dx, dy)){ addLog("Impossible d'annexer", "Il faut être adjacent à ton territoire.", 1); return; }
    const attType = src.unit.type;
    let att = src.unit.type;
    let def = dst.unit.type;
    if (dst.structure === 'city' && dst.owner === dst.unit.owner) def += DEF_BONUS_CITY;
    const r = beats(att, def);

    if (r === 1){
      dst.unit = { ...src.unit, moved: true };
      src.unit = null;
      dst.owner = 1;
      addLog(`Victoire en ${dx},${dy}`, `Ton ${unitName(dst.unit.type)} l'emporte.`, 1);
    } else if (r === -1){
      src.unit = null;
      addLog(`Défaite en ${dx},${dy}`, `Ton ${unitName(attType)} perd le duel.`, 1);
    } else {
      src.unit = null; dst.unit = null;
      addLog(`Égalité en ${dx},${dy}`, `Les deux unités périssent.`, 1);
    }
    return;
  }

  // Ville : capture/entrée
  if (dst.structure === 'city'){
    const wasEnemy = isEnemy(1, dst.owner);
    if (wasEnemy && !canAnnex(1, dx, dy)){ addLog("Impossible d'annexer", "Il faut être adjacent à ton territoire.", 1); return; }
    if (wasEnemy) dst.owner = 1;
    dst.unit = { ...src.unit, moved: true };
    src.unit = null;
    addLog(wasEnemy ? 'Ville capturée' : 'Entrée dans la ville', `En ${dx},${dy}`, 1);
    return;
  }

  // Case normale
  if (dst.owner !== 1 && !canAnnex(1, dx, dy)){
    addLog("Impossible d'annexer", "Il faut être adjacent à ton territoire.", 1);
    return;
  }
  dst.unit = { ...src.unit, moved: true };
  dst.owner = 1;
  src.unit = null;
  addLog(`Prise de ${dx},${dy}`, 'La case passe sous ton contrôle.', 1);
}

function moveUnitAI(sx, sy, dx, dy, owner){
  const src = cell(sx, sy), dst = cell(dx, dy);
  if (!src?.unit || src.unit.moved || src.unit.owner !== owner) return;
  if (dst?.structure === 'tower' && isEnemy(owner, dst.owner)) return;
  if (moveCostUnit(src.unit.type, src, dst, owner) === Infinity) return;

  // Fusion alliée (même type)
  if (dst?.unit && !isEnemy(owner, dst.unit.owner) && dst.unit.type === src.unit.type){
    dst.unit.level = (dst.unit.level||1) + (src.unit.level||1);
    dst.unit.moved = true; src.unit = null; dst.owner = owner;
    return;
  }

  // Combat
  if (dst?.unit && isEnemy(owner, dst.unit.owner)){
    if (!canAnnex(owner, dx, dy)) return;
    let att = src.unit.type, def = dst.unit.type;
    if (dst.structure === 'city' && dst.owner === dst.unit.owner) def += DEF_BONUS_CITY;
    const r = beats(att, def);
    if (r === 1){ dst.unit = { ...src.unit, moved:true }; src.unit = null; dst.owner = owner; }
    else if (r === -1){ src.unit = null; }
    else { src.unit = null; dst.unit = null; }
    return;
  }

  // Ville : capture/entrée
  if (dst.structure === 'city'){
    const wasEnemy = isEnemy(owner, dst.owner);
    if (wasEnemy && !canAnnex(owner, dx, dy)) return;
    if (wasEnemy) dst.owner = owner;
    dst.unit = { ...src.unit, moved:true }; src.unit = null;
    return;
  }

  // Case normale
  if (dst.owner !== owner && !canAnnex(owner, dx, dy)) return;
  dst.unit = { ...src.unit, moved:true }; dst.owner = owner; src.unit = null;
}

function moveShip(sx, sy, dx, dy){
  const src = cell(sx, sy), dst = cell(dx, dy);
  if (!src?.ship || src.ship.moved || src.ship.owner !== 1 || dst?.ship) return;
  if (!passableForShip(src, dst, 1, src.ship.kind)) return;
  dst.ship = { ...src.ship, moved: true };
  src.ship = null;
}
function moveShipAI(sx, sy, dx, dy, owner){
  const src = cell(sx, sy), dst = cell(dx, dy);
  if (!src?.ship || src.ship.moved || src.ship.owner !== owner || dst?.ship) return;
  if (!passableForShip(src, dst, owner, src.ship.kind)) return;
  dst.ship = { ...src.ship, moved: true }; src.ship = null;
}

function tryUpgradeAtCity(x,y,toTypeMaybe){
  const c=cell(x,y);
  if(!c || c.structure!=='city' || c.owner!==1 || !c.unit || c.unit.owner!==1){
    addLog("Aucune unité à améliorer dans la ville.", null, 1);
    return;
  }
  let to = toTypeMaybe || (c.unit.type===1?2:(c.unit.type===2?3:3));
  if(c.unit.type===3){ addLog("Déjà au rang maximum.", null, 1); return; }
  const cost=upgradeCost(c.unit.type,to);
  if((gold[1]||0)<cost){ addLog("Or insuffisant pour l'amélioration",`Coût ${cost} or`,1); return; }
  gold[1]-=cost; c.unit.type=to; c.unit.moved=true;
  addLog(`Amélioration: ${UNITS[to].name}`,`En ${x},${y} (coût ${cost})`,1);
  render();
}

const $ = id => document.getElementById(id);
const B = id => document.getElementById(id);

$('buildCity').onclick=()=>{
  if(!selected) return;
  const c=cell(selected.x,selected.y);
  const cc=cityCost(1);
  if((gold[1]||0)<cc || c?.structure!=='none' || c?.terrain!=='land') return;
  c.structure='city'; c.owner=1; gold[1]-=cc;
  addLog('Ville fondée',`En ${selected.x},${selected.y} (coût ${cc} or)`,1);
  render();
};
$('buildTower').onclick=()=>{
  if(!selected) return;
  const c=cell(selected.x,selected.y);
  if((gold[1]||0)<3 || c?.structure!=='none' || c?.terrain!=='land') return;
  c.structure='tower'; c.owner=1; gold[1]-=3;
  addLog('Tour bâtie',`En ${selected.x},${selected.y}`,1);
  render();
};

B('makeSloop').onclick   = ()=>beginShipBuild('sloop');
B('makeBrig').onclick    = ()=>beginShipBuild('brig');
B('makeGalleon').onclick = ()=>beginShipBuild('galleon');
B('loadShip').onclick    = ()=>loadShip();
B('disembark').onclick   = ()=>disembark();

$('recFarmer').onclick = ()=>{
  const s=selected; if(!s) return;
  const c = cell(s.x,s.y);
  if(!c || c.structure!=='city' || c.owner!==1) return;
  beginSpawnFromCity(s.x,s.y,1);
};
$('recMilitia').onclick = ()=>{
  const s=selected; if(!s) return;
  const c = cell(s.x,s.y);
  if(!c || c.structure!=='city' || c.owner!==1) return;
  beginSpawnFromCity(s.x,s.y,2);
};
$('recSoldier').onclick = ()=>{
  const s=selected; if(!s) return;
  const c = cell(s.x,s.y);
  if(!c || c.structure!=='city' || c.owner!==1) return;
  beginSpawnFromCity(s.x,s.y,3);
};

$('upFarmMil').onclick = ()=>{
  const s=selected; if(!s) return;
  const c = cell(s.x,s.y);
  if(!c || c.structure!=='city' || c.owner!==1) return;
  tryUpgradeAtCity(s.x,s.y,2);
};
$('upMilSold').onclick = ()=>{
  const s=selected; if(!s) return;
  const c = cell(s.x,s.y);
  if(!c || c.structure!=='city' || c.owner!==1) return;
  tryUpgradeAtCity(s.x,s.y,3);
};

function recruitLabel(type, cost){
  const u = UNITS[type];
  return `<span class="title">Recruter ${u.name}</span><span class="meta">Coût ${cost} · Loyer ${u.upkeep} · PM ${u.move}</span>`;
}

function capacityLeft(shipCellObj){
  const ship = shipCellObj.ship || shipCellObj;
  return SHIPS[ship.kind].cap - (ship.cargo?.reduce((a,u)=>a+(u.level||1),0) || 0);
}
function loadShip(){
  const s = selected && cell(selected.x,selected.y);
  if(!s?.ship || s.ship.moved || s.ship.owner!==1) return;
  if(!s.ship.cargo) s.ship.cargo=[];
  const capLeft = capacityLeft(s);
  const pos = neighbors(selected.x,selected.y).find(([nx,ny])=>{
    const t=cell(nx,ny);
    return t?.unit && t.unit.owner===1 && (t.unit.level||1) <= capLeft;
  });
  if(!pos){ addLog("Aucune unité admissible à embarquer (capacité insuffisante).", null, 1); return; }
  const [ux,uy]=pos; const u=cell(ux,uy);
  s.ship.cargo.push({...u.unit}); u.unit=null;
  addLog('Embarquement', `Depuis ${ux},${uy}`, 1);
  render();
}
function disembark(){
  const s = selected && cell(selected.x, selected.y);
  if(!s?.ship || s.ship.moved || s.ship.owner!==1 || !(s.ship.cargo && s.ship.cargo.length)) return;
  const spot = neighbors(selected.x, selected.y).find(([nx,ny])=>{
    const t=cell(nx,ny);
    return !!t && (t.terrain==='land' || t.terrain==='forest') && !t.unit
      && !(t.structure==='tower' && isEnemy(1,t.owner))
      && (t.owner===0 || canAnnex(1,nx,ny));
  });
  if(!spot){ addLog("Débarquement interdit : aucun emplacement valide (terre libre requise).", null, 1); return; }
  const [dx,dy]=spot; const t=cell(dx,dy);
  const u = s.ship.cargo.shift();
  t.unit = { ...u, moved:true }; t.owner = 1; s.ship.moved = true;
  addLog('Débarquement', `En ${dx},${dy}`, 1);
  render();
}

let shipBuildMode = null;
function shipBuildCandidates(ux,uy,kind,owner=1){
  const uCell = cell(ux,uy); if(!uCell) return [];
  const spots=[];
  for (const [nx,ny] of neighbors(ux,uy)){
    const t = cell(nx,ny);
    if (!t || t.ship) continue;
    if (!passableForShip(uCell, t, owner, kind)) continue;
    spots.push([nx,ny]);
  }
  return spots;
}
function beginShipBuild(kind){
  const sel = selected && cell(selected.x,selected.y);
  if(!sel || !sel.unit || sel.unit.owner!==1){
    addLog("Sélectionne d'abord une unité sur la côte.", null, 1);
    return;
  }
  const cost = shipBuildCost(kind, 1);
  if((gold[1]||0) < cost){ addLog("Pas assez d'or", `Coût ${cost} or`, 1); return; }
  const spots = shipBuildCandidates(selected.x, selected.y, kind, 1);
  if (!spots.length){
    addLog("Pas d'emplacement de mise à l'eau à proximité.", "Aucune case d'eau adjacente libre.", 1);
    return;
  }
  shipBuildMode = { kind, from:{x:selected.x,y:selected.y}, cost, spots };
  spawnChoices = spots.slice();
  addLog(`Choisis l'emplacement du ${SHIPS[kind].name}`, "Clique sur une case d'eau adjacente surlignée.", 1);
  drawOverlay();
}

function spawnSpotsAroundCity(x,y, owner, _type){
  const spots = [];
  for (const [nx,ny] of neighbors(x,y)){
    const t = cell(nx,ny);
    if (!t) continue;
    if (!(t.terrain==='land' || t.terrain==='forest')) continue;
    if (t.structure !== 'none') continue;
    if (t.unit || t.ship) continue;
    if (t.owner !== owner && !canAnnex(owner, nx, ny)) continue;
    spots.push([nx,ny]);
  }
  return spots;
}

function updateActionsPanel(){
  const sel=selected?cell(selected.x,selected.y):null, myTurn=(turn===1);
  const cc=cityCost(1); const bc=document.getElementById('buildCity'); bc.textContent=`Construire Ville (${cc} or)`;
  const onUnit = myTurn && sel && selected.kind==='unit' && sel.unit && !sel.unit.moved;
  const sSpots = onUnit ? shipBuildCandidates(selected.x,selected.y,'sloop',1).length    : 0;
  const bSpots = onUnit ? shipBuildCandidates(selected.x,selected.y,'brig',1).length     : 0;
  const gSpots = onUnit ? shipBuildCandidates(selected.x,selected.y,'galleon',1).length  : 0;
  const costS = shipBuildCost('sloop',   1);
const costB = shipBuildCost('brig',    1);
const costG = shipBuildCost('galleon', 1);

  B('makeSloop').textContent   = `Sloop 1 mât (${costS} or)`;
  B('makeBrig').textContent    = `Brigantin 2 mâts (${costB} or)`;
  B('makeGalleon').textContent = `Galion 3 mâts (${costG} or)`;

  B('makeSloop').disabled   = !(onUnit && sSpots>0 && (gold[1]||0)>=costS);
  B('makeBrig').disabled    = !(onUnit && bSpots>0 && (gold[1]||0)>=costB);
  B('makeGalleon').disabled = !(onUnit && gSpots>0 && (gold[1]||0)>=costG);

  const ownEmptyLand=myTurn&&sel&&selected.kind==='empty'&&sel.terrain==='land'&&sel.structure==='none';
  B('buildCity').disabled=!(ownEmptyLand&&(gold[1]||0)>=cc);
  B('buildTower').disabled=!(ownEmptyLand&&(gold[1]||0)>=3);
  const onShip=myTurn&&sel&&selected.kind==='ship'&&sel.ship&&!sel.ship.moved&&sel.ship.owner===1;
  B('loadShip').disabled=!(onShip && capacityLeft(sel)>0 && neighbors(selected.x,selected.y).some(([nx,ny])=>{const t=cell(nx,ny);return t?.unit && t.unit.owner===1 && (t.unit.level||1)<=capacityLeft(sel);} ) );
  B('disembark').disabled = !(onShip && (sel.ship.cargo?.length||0)>0 && neighbors(selected.x,selected.y).some(([nx,ny])=>{
    const t = cell(nx,ny);
    return !!t && (t.terrain==='land' || t.terrain==='forest') && !t.unit && !(t.structure==='tower' && isEnemy(1,t.owner)) && (t.owner===0 || canAnnex(1,nx,ny));
  }));
  const onCity = myTurn && sel &&
  ((sel.structure==='city' && sel.owner===1) || false);
  const cF = recruitCost(1,1), cM = recruitCost(2,1), cS = recruitCost(3,1);
  document.getElementById('recFarmer').innerHTML  = recruitLabel(1, cF);
  document.getElementById('recMilitia').innerHTML = recruitLabel(2, cM);
  document.getElementById('recSoldier').innerHTML = recruitLabel(3, cS);
  const spots = onCity ? spawnSpotsAroundCity(selected.x,selected.y,1,0) : [];
  const anySpot = spots.length>0;
  B('recFarmer').disabled  = !(onCity && anySpot && (gold[1]||0)>=cF);
  B('recMilitia').disabled = !(onCity && anySpot && (gold[1]||0)>=cM);
  B('recSoldier').disabled = !(onCity && anySpot && (gold[1]||0)>=cS);
  let canUpFM=false, canUpMS=false, labFM='Améliorer Fermier → Milice', labMS='Améliorer Milice → Soldat';
  if(onCity && sel.unit && sel.unit.owner===1){
    if(sel.unit.type===1){ const price=upgradeCost(1,2); labFM += ` (${price} or)`; canUpFM=(gold[1]||0)>=price; }
    if(sel.unit.type===2){ const price=upgradeCost(2,3); labMS += ` (${price} or)`; canUpMS=(gold[1]||0)>=price; }
  }
  document.getElementById('upFarmMil').textContent = labFM;
  document.getElementById('upMilSold').textContent = labMS;
  B('upFarmMil').disabled = !(onCity && sel?.unit?.owner===1 && sel.unit.type===1 && canUpFM);
  B('upMilSold').disabled = !(onCity && sel?.unit?.owner===1 && sel.unit.type===2 && canUpMS);
  const ids = ['buildCity','buildTower','recFarmer','recMilitia','recSoldier','upFarmMil','upMilSold','makeSloop','makeBrig','makeGalleon','loadShip','disembark'];
  const anyVisible = ids.some(id => !B(id).disabled);
  let msg = document.getElementById('actionsMsg');
  if (!msg){
    msg = document.createElement('div');
    msg.id = 'actionsMsg';
    msg.className = 'hint-msg';
    document.getElementById('actions').appendChild(msg);
  }
  msg.style.display = anyVisible ? 'none' : 'block';
  if (!anyVisible){
    msg.textContent = selected ? "Aucune action possible ici." : "Clique sur un territoire, une ville ou une unité pour accéder à ses actions.";
  }
}

function drawTerrain(){
  const Wpx=STEP_X*(W-1)+HEX_W, Hpx=STEP_Y*(H-1)+HEX_H+HEX_H/2;
  WpxCached=Wpx; HpxCached=Hpx;
  stageEl.style.width=Wpx+'px'; stageEl.style.height=Hpx+'px';
  terrain.setAttribute('width',Wpx); terrain.setAttribute('height',Hpx); terrain.setAttribute('viewBox',`0 0 ${Wpx} ${Hpx}`); terrain.innerHTML='';
  const defs=document.createElementNS(terrain.namespaceURI,'defs');
  const waves=(id,stroke,opacity)=>{const p=document.createElementNS(terrain.namespaceURI,'pattern');p.id=id;p.setAttribute('patternUnits','userSpaceOnUse');p.setAttribute('width','12');p.setAttribute('height','10');const path=document.createElementNS(terrain.namespaceURI,'path');path.setAttribute('d','M0 6 Q3 8 6 6 T12 6');path.setAttribute('fill','none');path.setAttribute('stroke',stroke);path.setAttribute('stroke-width','1.2');path.setAttribute('opacity',opacity);p.appendChild(path);defs.appendChild(p);};
  waves('wavesShallow','#2b6da3',0.40); waves('wavesDeep','#9ecbff',0.22);
  const tree=document.createElementNS(terrain.namespaceURI,'pattern'); tree.id='treePattern'; tree.setAttribute('patternUnits','userSpaceOnUse'); tree.setAttribute('width','14'); tree.setAttribute('height','14');
  const g=document.createElementNS(terrain.namespaceURI,'g'); const tri=document.createElementNS(terrain.namespaceURI,'path'); tri.setAttribute('d','M7 2 L2 9 L12 9 Z'); tri.setAttribute('fill','rgba(34,85,34,.55)');
  const trunk=document.createElementNS(terrain.namespaceURI,'path'); trunk.setAttribute('d','M7 9 L7 12'); trunk.setAttribute('stroke','rgba(60,40,20,.7)'); trunk.setAttribute('stroke-width','2'); g.appendChild(tri); g.appendChild(trunk); tree.appendChild(g); defs.appendChild(tree);
  terrain.appendChild(defs);

  const gT=document.createElementNS(terrain.namespaceURI,'g'); terrain.appendChild(gT);
  for (let y=0; y<H; y++) for (let x=0; x<W; x++){
    const c = cell(x,y);
    if (!c) continue;
    const {cx,cy} = hexCenter(x,y);
    const poly=document.createElementNS(terrain.namespaceURI,'polygon');
    poly.setAttribute('points', svgHexPoints(cx,cy));
    let fill;
    if (c.terrain==='deep')    fill=getComputedStyle(document.documentElement).getPropertyValue('--deep').trim();
    else if (c.terrain==='shallow') fill=getComputedStyle(document.documentElement).getPropertyValue('--shallow').trim();
    else {
      const base=regionColor(c.owner||0);
      fill=(c.terrain==='forest') ? mix(base,'#6cab6c',0.22) : base;
    }
    poly.setAttribute('fill',fill);
    poly.setAttribute('stroke',fill);
    poly.setAttribute('stroke-width','1');
    poly.setAttribute('stroke-linejoin','round');
    poly.setAttribute('vector-effect','non-scaling-stroke');
    poly.setAttribute('shape-rendering','geometricPrecision');
    gT.appendChild(poly);
    if (c.terrain==='shallow' || c.terrain==='deep'){
      const top=document.createElementNS(terrain.namespaceURI,'polygon');
      top.setAttribute('points', svgHexPoints(cx,cy,0.992));
      top.setAttribute('fill', `url(#${c.terrain==='shallow'?'wavesShallow':'wavesDeep'})`);
      top.setAttribute('opacity','1'); gT.appendChild(top);
    } else if (c.terrain==='forest'){
      const ov=document.createElementNS(terrain.namespaceURI,'polygon');
      ov.setAttribute('points', svgHexPoints(cx,cy,0.992));
      ov.setAttribute('fill','url(#treePattern)');
      ov.setAttribute('opacity','1'); gT.appendChild(ov);
    }
    if (c.terrain === 'land'){
      const r = hash(c.x*13.3, c.y*7.7);
      if (r < 0.28){
        const grp = document.createElementNS(terrain.namespaceURI,'g');
        grp.setAttribute('opacity','0.35');
        const jitterX = (hash(c.x*51.1, c.y*27.9)-0.5) * (HEX_W*0.20);
        const jitterY = (hash(c.x*17.2, c.y*39.8)-0.5) * (HEX_H*0.20);
        grp.setAttribute('transform', `translate(${cx + jitterX},${cy + jitterY})`);
        const rock = (sx,sy,sz)=>{
          const p=document.createElementNS(terrain.namespaceURI,'path');
          p.setAttribute('d', `M ${sx-sz} ${sy} q ${sz*0.9} ${-sz*0.8} ${sz*2} 0 q ${-sz*0.8} ${sz*0.9} ${-sz*2} 0 Z`);
          p.setAttribute('fill', '#7f7362'); p.setAttribute('stroke', '#a49786'); p.setAttribute('stroke-width', '0.6');
          grp.appendChild(p);
        };
        rock(0, 0, 2.0); if (r < 0.18) rock(6, 3, 1.3); if (r < 0.10) rock(-5, 3, 1.1);
        gT.appendChild(grp);
      }
    }
  }
  overlay.setAttribute('width',Wpx); overlay.setAttribute('height',Hpx); overlay.setAttribute('viewBox',`0 0 ${Wpx} ${Hpx}`);
  gridEl.style.width=Wpx+'px'; gridEl.style.height=Hpx+'px';
}

function drawOverlay(){
  overlay.innerHTML='';
  const gTheo=document.createElementNS(overlay.namespaceURI,'g'),
        gReach=document.createElementNS(overlay.namespaceURI,'g');
  overlay.appendChild(gTheo); overlay.appendChild(gReach);
  const drawList=(arr,group,fill)=>{
    for(const [x,y] of arr){
      const {cx,cy}=hexCenter(x,y);
      const p=document.createElementNS(overlay.namespaceURI,'polygon');
      p.setAttribute('points',svgHexPoints(cx,cy,0.985));
      p.setAttribute('fill',fill); p.setAttribute('stroke',fill);
      p.setAttribute('stroke-width','1'); p.setAttribute('stroke-linejoin','round');
      group.appendChild(p);
    }
  };
  drawList(reachTheo,gTheo,getComputedStyle(document.documentElement).getPropertyValue('--theo-fill').trim());
  drawList(reach,gReach,getComputedStyle(document.documentElement).getPropertyValue('--reach-fill').trim());
  if (spawnChoices && spawnChoices.length){
    drawList(spawnChoices, gReach, 'rgba(255,204,0,0.28)');
  }
}

function applyView(){
  worldEl.style.transformOrigin='0 0';
  worldEl.style.transform=`translate(${panX}px, ${panY}px) scale(${zoom})`;
  const zl=document.getElementById('zoomLabel'); if(zl) zl.textContent=Math.round(zoom*100)+'%';
}
function centerBoard(){
  const vw=boardEl.clientWidth, vh=boardEl.clientHeight;
  const targetW=WpxCached*zoom, targetH=HpxCached*zoom;
  panX=Math.floor((vw-targetW)/2);
  panY=Math.floor((vh-targetH)/2);
  applyView();
}

function render(){
  drawTerrain();
  if (selected) {
    if (!inb(selected.x, selected.y)) { selected = null; }
    else {
      const cSel = cell(selected.x, selected.y);
      const ok =
        selected.kind==='unit'  ? !!cSel?.unit :
        selected.kind==='ship'  ? !!cSel?.ship :
        selected.kind==='city'  ? (cSel?.structure==='city' && cSel?.owner===1) :
        selected.kind==='empty' ? (!!cSel && !cSel.unit && !cSel.ship) : false;
      if (!ok) selected = null;
    }
  }
  if (S.length !== W * H){
    overlay.innerHTML = '';
    gridEl.innerHTML  = '';
    updateHUD();
    applyView();
    return;
  }
  reach = []; reachTheo = [];
  if (selected){
    const c = cell(selected.x, selected.y);
    if (selected.kind === 'unit' && c?.unit){
      reachTheo = reachableFrom(selected.x, selected.y, 'unit', c.unit.type);
      reach     = c.unit.moved ? [] : reachTheo.slice();
    }
    if (selected.kind === 'ship' && c?.ship){
      reachTheo = reachableFrom(selected.x, selected.y, 'ship', c.ship.kind);
      reach     = c.ship.moved ? [] : reachTheo.slice();
    }
  }
  drawOverlay();
  gridEl.innerHTML = '';
  for (let y=0; y<H; y++) for (let x=0; x<W; x++){
    const c = cell(x,y);
    if (!c) continue;
    const {cx,cy} = hexCenter(x,y);
    const d = document.createElement('div');
    d.className = 'hex';
    d.style.left = cx+'px'; d.style.top = cy+'px';
    d.style.width = HEX_W+'px'; d.style.height = HEX_H+'px';
    d.style.clipPath='polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)';
    d.dataset.x = x; d.dataset.y = y;
    d.addEventListener('click', onCellClick);
    const isLand = (c.terrain === 'land' || c.terrain === 'forest');
    const hasFrontier = isLand && neighbors(x,y).some(([nx,ny])=>{
      const n = cell(nx,ny);
      if (!n) return false;
      const nLand = (n.terrain === 'land' || n.terrain === 'forest');
      return nLand && n.owner !== c.owner;
    });
    if (hasFrontier){
      d.classList.add('frontier');
      if (c.owner === 1) d.classList.add('owned1');
      else if (c.owner === 2) d.classList.add('owned2');
    }
    if (selected && selected.x===x && selected.y===y) d.classList.add('selected');
    const hidden = enemyHiddenForPlayer(c);
    if (c.structure === 'city' && !hidden){
      const v=document.createElement('div'); v.className='city';
      if (c.owner===1 && c.terrain==='forest') v.classList.add('camo');
      v.appendChild(svgCastle()); d.appendChild(v);
      const h=document.createElement('div'); h.className='hint'; h.textContent='+2'; d.appendChild(h);
    }
    if (c.structure === 'tower' && !hidden){
      const t=document.createElement('div'); t.className='tower';
      if (c.owner===1 && c.terrain==='forest') t.classList.add('camo');
      t.appendChild(svgRook()); d.appendChild(t);
    }
    if (c.unit && !hidden){
      const u=document.createElement('div'); u.className='badge';
      u.style.background=ownerColor(c.unit.owner);
      if (c.unit.owner===1 && c.terrain==='forest') u.classList.add('camo');
      u.appendChild(svgIconUnit(c.unit.type)); d.appendChild(u);
    }
    if (c.ship){
      const s=document.createElement('div'); s.className='ship';
      s.style.background=ownerColor(c.ship.owner);
      s.appendChild(svgShip(c.ship.kind));
      const h=document.createElement('div'); h.className='hint';
      h.textContent=`${(c.ship.cargo?.reduce((a,u)=>a+(u.level||1),0)||0)}/${SHIPS[c.ship.kind].cap}`;
      d.appendChild(s); d.appendChild(h);
    }
    gridEl.appendChild(d);
  }
  updateHUD();
  updateActionsPanel();
  renderSummary();
}

function svgIconUnit(type){const s=elSVG('0 0 24 24'); if(type===1){path(s,'M6 3 L6 15',2.6);path(s,'M3 7 L9 7',2.6);path(s,'M9 4 L9 8',2.6);path(s,'M6 15 L6 21',2.6);path(s,'M12 14 C12 12, 15 12, 15 14 C15 16, 12 16,12 14',2.2);return s;} if(type===2){circle(s,12,12,5.5,2.6);path(s,'M4 20 L20 4',2.6);return s;} path(s,'M6 10 C6 6, 18 6, 18 10',2.6);path(s,'M6 10 L18 10',2.6);path(s,'M12 11 L12 20',2.6);path(s,'M9 20 L15 20',2.6);return s;}
function svgShip(kind){const s=elSVG('0 0 48 28'); pathC(s,'M4 18 L44 18 L38 24 L10 24 Z',1.5,'#444'); line(s,20,6,20,18,2); if(kind!=='sloop') line(s,28,6,28,18,2); return s;}
function svgCastle(){const s=elSVG('0 0 24 16','castle'); pathW(s,'M2 6 L22 6 L22 14 L2 14 Z',1.6); pathW(s,'M2 6 L2 3 L5 3 L5 6 M8 6 L8 3 L11 3 L11 6 M14 6 L14 3 L17 3 L17 6 M20 6 L20 3 L22 3 L22 6',1.6); pathW(s,'M10 14 L10 10 L14 10 L14 14',1.6); return s;}
function svgRook(){const s=elSVG('0 0 24 24'); pathFill(s,'M5 20 L19 20 L19 18 L17 16 L17 11 L18 10 L18 7 L15 7 L15 9 L12 9 L12 7 L9 7 L9 9 L6 9 L6 7 L5 7 L5 10 L6 11 L6 16 L5 18 Z','#777','#555',1.2); return s;}
function elSVG(vb,cls){const s=document.createElementNS('http://www.w3.org/2000/svg','svg'); s.setAttribute('viewBox',vb); s.classList.add('icon'); if(cls) s.classList.add(cls); return s;}
function path(s,d,sw=2){const p=document.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d',d); p.setAttribute('fill','none'); p.setAttribute('stroke','#fff'); p.setAttribute('stroke-width',sw); p.setAttribute('stroke-linecap','round'); p.setAttribute('stroke-linejoin','round'); s.appendChild(p);}
function pathW(s,d,sw=2){const p=document.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d',d); p.setAttribute('fill','none'); p.setAttribute('stroke','#fff'); p.setAttribute('stroke-width',sw); p.setAttribute('stroke-linecap','round'); p.setAttribute('stroke-linejoin','round'); s.appendChild(p);}
function pathC(s,d,sw=2,fill='#444'){const p=document.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d',d); p.setAttribute('fill',fill); p.setAttribute('stroke','#eee'); p.setAttribute('stroke-width',sw); p.setAttribute('stroke-linejoin','round'); s.appendChild(p);}
function pathFill(s,d,fill='#777',stroke='#555',sw=1){const p=document.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d',d); p.setAttribute('fill',fill); p.setAttribute('stroke',stroke); p.setAttribute('stroke-width',sw); p.setAttribute('stroke-linejoin','round'); s.appendChild(p);}
function circle(s,cx,cy,r,sw=2){const c=document.createElementNS('http://www.w3.org/2000/svg','circle'); c.setAttribute('cx',cx); c.setAttribute('cy',cy); c.setAttribute('r',r); c.setAttribute('fill','none'); c.setAttribute('stroke','#fff'); c.setAttribute('stroke-width',sw); s.appendChild(c);}
function line(s,x1,y1,x2,y2,sw=2){const l=document.createElementNS('http://www.w3.org/2000/svg','line'); l.setAttribute('x1',x1); l.setAttribute('y1',y1); l.setAttribute('x2',x2); l.setAttribute('y2',y2); l.setAttribute('stroke','#eee'); l.setAttribute('stroke-width',sw); s.appendChild(l);}

function updateHUD(){
  const t = document.getElementById('turnLabel');
  if (t) t.textContent = (turn===1 ? 'Joueur' : `IA ${turn-1}`);
  const y = document.getElementById('yearLabel');
  if (y) y.textContent = YEAR;
}
function addLog(s,d=null,owner=null){ const e=document.createElement('div'); e.className='entry'; if(owner) e.dataset.owner=owner; e.innerHTML=`<div class="summary">• ${s}</div><div class="detail">${d?d:s}</div>`; e.querySelector('.summary').onclick=()=>e.classList.toggle('open'); logEl.insertAdjacentElement('afterbegin',e); }

function onCellClick(e){
  if (justPanned) return;
  const x=+e.currentTarget.dataset.x, y=+e.currentTarget.dataset.y, c=cell(x,y);
  if (shipBuildMode){
    const ok = shipBuildMode.spots.some(([sx,sy])=>sx===x && sy===y);
    if (ok){
      if ((gold[1]||0) < shipBuildMode.cost){
        addLog("Pas assez d'or", `Coût ${shipBuildMode.cost} or`, 1);
      } else {
        const t = cell(x,y);
        t.ship = { owner:1, kind: shipBuildMode.kind, cargo:[], moved:true, hp: SHIPS[shipBuildMode.kind].hp };
        gold[1] -= shipBuildMode.cost;
        addLog(`${SHIPS[shipBuildMode.kind].name} mis à l'eau`, `En ${x},${y}`, 1);
      }
    }
    shipBuildMode = null; spawnChoices = []; render();
    return;
  }
  if (spawnMode){
    const match = spawnMode.spots.some(([sx,sy])=>sx===x && sy===y);
    if (match){
      if ((gold[1]||0) < spawnMode.cost){
        addLog("Pas assez d'or", `Coût ${spawnMode.cost} or`, 1);
      } else if (spawnUnit(x,y,{owner:1,type:spawnMode.type,level:1},true)){
        gold[1] -= spawnMode.cost;
        addLog(`Recrutement: ${UNITS[spawnMode.type].name}`, `Posé en ${x},${y} (coût ${spawnMode.cost})`, 1);
      }else{
        addLog("Échec de pose", "La case n'est plus libre.", 1);
      }
    }
    spawnMode = null; spawnChoices = []; render();
    return;
  }
  if(selected && reach.some(([mx,my])=>mx===x&&my===y)){
    if(selected.kind==='unit') moveUnit(selected.x,selected.y,x,y,false);
    else if(selected.kind==='ship') moveShip(selected.x,selected.y,x,y);
    const here=cell(x,y);
    selected={x,y,kind:(here?.ship?'ship':(here?.unit?'unit':(here?.structure==='city'&&here?.owner===1?'city':'empty')))};
    render(); return;
  }
  if(turn!==1){ selected=null; render(); return; }
  if(c?.unit && c.unit.owner===1) selected={x,y,kind:'unit'};
  else if(c?.ship && c.ship.owner===1) selected={x,y,kind:'ship'};
  else if(c?.structure==='city' && c.owner===1) selected={x,y,kind:'city'};
  else if((c?.terrain==='land'||c?.terrain==='forest') && c.owner===1 && !c.unit && !c.ship && c.structure==='none') selected={x,y,kind:'empty'};
  else selected=null;
  render();
}

endBtn.onclick = () => {
  if (uiLocked) return;
  uiLocked = true;
  endBtn.disabled = true;
  endTurn();
};
document.getElementById('restart').onclick=()=>{ setSeed(CURRENT_SEED); const aiCount=+document.getElementById('aiCount').value||0; const allied=+document.getElementById('aiAllied').value; const diff=+document.getElementById('difficulty').value||2; genMap(CURRENT_SIZE,aiCount,allied,diff); uiLocked=false; endBtn.disabled=false; render(); centerBoard(); addLog(`Relance de la carte (seed ${CURRENT_SEED})`,null,1); };
document.getElementById('menu').onclick=()=>{ uiLocked=false; endBtn.disabled=false; showStart(); };

function applyBankruptcy(owner){
  const upk=upkeep(owner);
  if((gold[owner]||0)>=upk) return;
  for(const c of S){ if(c.unit&&c.unit.owner===owner)c.unit=null; if(c.ship&&c.ship.owner===owner)c.ship=null; }
  gold[owner]=Math.max(0,gold[owner]||0);
  addLog(`${owner===1?'Joueur':('IA '+(owner-1))} en banqueroute : armée dissoute`,`Loyer (${upk.toFixed(1)}) > or disponible.`,owner);
}

function endTurn(){
  const inc = income(turn);
  gold[turn] = (gold[turn] || 0) + inc;
  const upk = upkeep(turn);
  gold[turn] -= upk;
  addLog(`Tour ${turn===1?'Joueur':'IA '+(turn-1)} : +${inc} or, -${upk.toFixed(1)} or de loyer`, null, turn);

  // -> vérifier la banqueroute du joueur QUI VIENT DE JOUER
  applyBankruptcy(turn);

  recalcMoved(false); selected=null;
  turn++;
  if (turn > TOTAL_PLAYERS) {  turn = 1;  YEAR++; }
  render(); checkVictory();
  if (turn !== 1){
    setTimeout(()=>aiTurn(turn),250);
  } else {
    uiLocked=false;
    endBtn.disabled=false;
  }
}

function checkVictory(){
  const aiAlive=S.some(c=>(c.unit&&c.unit.owner>1)||(c.structure==='city'&&c.owner>1));
  const playerAlive=S.some(c=>(c.unit&&c.unit.owner===1)||(c.structure==='city'&&c.owner===1));
  if(!aiAlive) setTimeout(()=>alert("Victoire !"),60);
  if(!playerAlive) setTimeout(()=>alert("Défaite…"),60);
}

function nearestEnemyOrCity(x,y,owner){
  let best = null, bestD = 1e9;
  for (const c of S){
    const isTarget = (c.unit && isEnemy(owner, c.unit.owner)) || (c.structure === 'city' && isEnemy(owner, c.owner));
    if (!isTarget) continue;
    const d = hexDist({x,y}, c);
    if (d < bestD){ bestD = d; best = c; }
  }
  return best;
}

function nearestPlayerCoast(owner){
  let best = null, bestD = 1e9;
  for (const c of S){
    const isSea = (c.terrain === 'shallow' || c.terrain === 'deep');
    if (!isSea) continue;
    const touchesEnemyLand = neighbors(c.x,c.y).some(([nx,ny])=>{
      const t = cell(nx,ny);
      return t && isEnemy(owner, t.owner) && (t.terrain==='land' || t.terrain==='forest');
    });
    if (!touchesEnemyLand) continue;
    const d = Math.abs(c.x-(W>>1)) + Math.abs(c.y-(H>>1));
    if (d < bestD){ bestD = d; best = c; }
  }
  return best;
}

function aiTurn(owner){
  const RESERVE=[2,4,6,10][DIFFICULTY-1]||4;
  const vAI=S.filter(c=>c.structure==='city'&&c.owner===owner&&!c.unit&&!c.ship);
  for(const v of vAI){
    const tryRecruit=t=>{
      const cost=recruitCost(t,owner), upk=UNITS[t].upkeep, inc=income(owner), nextGold=(gold[owner]||0)-cost+inc-(upkeep(owner)+upk);
      if((gold[owner]||0)-cost>=RESERVE && nextGold>=0){
        const spots = spawnSpotsAroundCity(v.x,v.y,owner,t);
        if (spots.length){
          const [dx,dy] = spots[0];
          spawnUnit(dx,dy,{owner,type:t,level:1},true);
          gold[owner]-=cost;
          addLog(`IA ${owner-1} recrute un ${UNITS[t].name}`,null,owner);
          return true;
        }
      }
      return false;
    };
    if(tryRecruit(3)) continue; if(tryRecruit(2)) continue; tryRecruit(1);
  }
  const tilesAI=S.filter(c=>c.owner===owner&&(c.terrain==='land'||c.terrain==='forest')).length;
  const maxShips=Math.max(1,Math.floor(tilesAI/(DIFFICULTY>=3?6:8)));
  const curShips=S.filter(c=>c.ship&&c.ship.owner===owner).length;
  if(curShips<maxShips){
    const coastal=S.find(c=>c.unit&&c.unit.owner===owner&&neighbors(c.x,c.y).some(([nx,ny])=>{const t=cell(nx,ny);return !!t && t.terrain!=='land'&&!t.ship;}));
    if(coastal){
      const seaShallow=neighbors(coastal.x,coastal.y).find(([nx,ny])=>{const t=cell(nx,ny);return t?.terrain==='shallow'&&!t.ship;});
      const tryShip = seaShallow ? 'sloop' : 'brig';
      const shipDef = SHIPS[tryShip];
      const cost    = shipBuildCost(tryShip, owner);
      const upk     = shipDef.upkeep, inc = income(owner);

      const nextGold=(gold[owner]||0)-cost+inc-(upkeep(owner)+upk);
      if((gold[owner]||0)-cost>=RESERVE && nextGold>=0){
        const pos=seaShallow?seaShallow:neighbors(coastal.x,coastal.y).find(([nx,ny])=>{const t=cell(nx,ny);return !!t && (t.terrain==='deep'||t.terrain==='shallow')&&!t.ship;});
        if(pos){ const [sx,sy]=pos; gold[owner]-=cost; cell(sx,sy).ship={owner,kind:tryShip,cargo:[{...coastal.unit}],moved:true,hp:shipDef.hp}; coastal.unit=null; addLog(`IA ${owner-1} met un ${shipDef.name.toLowerCase()} à l'eau`,null,owner); }
      }
    }
  }
  const units=S.filter(c=>c.unit&&c.unit.owner===owner);
  for(const u of units){
    if(u.unit.moved) continue;
    const tgt=nearestEnemyOrCity(u.x,u.y,owner);
    const opts=reachableFrom(u.x,u.y,'unit',u.unit.type);
    if(opts.length && tgt){
      opts.sort((a,b)=>hexDist({x:a[0],y:a[1]},tgt)-hexDist({x:b[0],y:b[1]},tgt));
      const [nx,ny]=opts[0];
      moveUnitAI(u.x,u.y,nx,ny,owner,false);
    }
  }
  const boats=S.filter(c=>c.ship&&c.ship.owner===owner);
  for(const b of boats){
    if(b.ship.moved) continue;
    const shore=neighbors(b.x,b.y).find(([nx,ny])=>{
      const t=cell(nx,ny);
      return !!t && (t.terrain==='land'||t.terrain==='forest')&&!t.unit&&!(t.structure==='tower'&&isEnemy(owner,t.owner))&& (t.owner===0 || canAnnex(owner,nx,ny));
    });
    if(shore && b.ship.cargo&&b.ship.cargo.length){
      const [dx,dy]=shore; const t=cell(dx,dy); t.unit={...b.ship.cargo.shift(),moved:true}; t.owner=owner; b.ship.moved=true; addLog(`IA ${owner-1} débarque`,null,owner); continue;
    }
    const tgt=nearestPlayerCoast(owner); const opts=reachableFrom(b.x,b.y,'ship',b.ship.kind);
    if (tgt && opts.length){
      opts.sort((a,b2)=>hexDist({x:a[0],y:a[1]},tgt)-hexDist({x:b2[0],y:b2[1]},tgt));
      const [nx,ny] = opts[0]; moveShipAI(b.x, b.y, nx, ny, owner);
    }
  }
  render(); checkVictory(); endTurn();
}

function randomSeed(){ return (Math.random()*0xFFFFFFFF)>>>0; }

function hideStart(){ document.getElementById('start').classList.remove('show'); }
function showStart(){ document.getElementById('start').classList.add('show'); }

function startGame(sizeKey){
  CURRENT_SIZE = sizeKey;
  const aiCount = +document.getElementById('aiCount').value || 0;
  const allied  = +document.getElementById('aiAllied').value;
  const diff    = +document.getElementById('difficulty').value || 2;
  const sTxt    = document.getElementById('seedInput').value.trim();
  setSeed(sTxt || randomSeed());
  genMap(CURRENT_SIZE, aiCount, allied, diff);
  uiLocked=false; endBtn.disabled=false;
  hideStart();
  render(); centerBoard();
  document.documentElement.style.setProperty('--my', playerColor);
}

function initStartUI(){
  const sw = document.getElementById('swatches');
  sw.innerHTML = '';
  PLAYER_COLORS.forEach((c,i)=>{
    const b = document.createElement('button');
    b.className='swatch'; b.style.background=c.v; b.title=c.n;
    if (i===1) b.dataset.sel='1';
    b.onclick=()=>{
      playerColor=c.v;
      document.documentElement.style.setProperty('--my', playerColor);
      [...sw.children].forEach(el=>el.dataset.sel='0');
      b.dataset.sel='1';
    };
    sw.appendChild(b);
  });

  document.getElementById('diceSeed').onclick=()=>{
    const s = randomSeed();
    document.getElementById('seedInput').value = '0x'+s.toString(16);
    setSeed(s);
  };

  document.querySelectorAll('#start .sizes [data-size]').forEach(btn=>{
    btn.onclick = ()=> startGame(btn.dataset.size);
  });

  document.getElementById('zoomIn').onclick = ()=>{
    zoom = Math.min(MAX_ZOOM, +(zoom+ZOOM_STEP).toFixed(2)); applyView();
  };
  document.getElementById('zoomOut').onclick = ()=>{
    zoom = Math.max(MIN_ZOOM, +(zoom-ZOOM_STEP).toFixed(2)); applyView();
  };

  boardEl.addEventListener('mousedown', (e)=>{
    isDragging=true; justPanned=false;
    dragStartX=e.clientX; dragStartY=e.clientY;
    panStartX=panX; panStartY=panY;
    boardEl.classList.add('dragging');
  });
  window.addEventListener('mousemove', (e)=>{
    if(!isDragging) return;
    panX = panStartX + (e.clientX - dragStartX);
    panY = panStartY + (e.clientY - dragStartY);
    justPanned = true; applyView();
  });
  window.addEventListener('mouseup', ()=>{
    if(!isDragging) return;
    isDragging=false; boardEl.classList.remove('dragging');
    setTimeout(()=>justPanned=false, 50);
  });
}

initStartUI();
showStart();

})();
</script>
</body>
</html>